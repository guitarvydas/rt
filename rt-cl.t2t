% grammar rt 

  Main = TopLevel+
  TopLevel =
    | Defvar -- defvar
    | Defconst -- defconst
    | Defn -- defn
    | Defobj -- defobj
    | Import -- import

   kw<s> = s ~identTail

   Defvar = kw<"defvar"> Lval "=" Exp
   Defconst = kw<"defconst"> Lval "=" Exp
   Defn = kw<"defn"> ident Formals StatementBlock
   Defobj = kw<"defobj"> ident ObjFormals "{" InitStatement+ "}"
   Import = kw<"import"> ident

   StatementBlock = "{" Rec_Statement "}"

   Rec_Statement =
     | kw<"global"> ident CommaIdent* Rec_Statement? -- globals
     | IfStatement  -- if
     | kw<"pass"> Rec_Statement? -- pass
     | kw<"return"> ReturnExp -- return
     | ForStatement -- for
     | WhileStatement  -- while
     | TryStatement -- try
     | Assignment -- assignment
     | Lval Rec_Statement? -- call
   CommaIdent = "," ident

   InitStatement = "•" ident "=" Exp

   IfStatement = kw<"if"> Exp StatementBlock ElifStatement* ElseStatement? Rec_Statement?
   ElifStatement = kw<"elif"> Exp StatementBlock
   ElseStatement = kw<"else"> StatementBlock

   ForStatement = kw<"for"> ident kw<"in"> Exp StatementBlock Rec_Statement?
   WhileStatement = kw<"while"> Exp StatementBlock Rec_Statement?

   TryStatement = kw<"try"> StatementBlock ExceptBlock+ Rec_Statement?
   ExceptBlock =
     | kw<"except"> Exp kw<"as"> ident StatementBlock -- as
     | kw<"except"> ident StatementBlock -- basic
   
   Assignment = 
     | Lval "+=" Exp Rec_Statement? -- pluseq
     | "[" Lval CommaLval+ "]" "=" Exp Rec_Statement? -- multiple
     | Lval "=" Exp Rec_Statement? -- single

   CommaLval = "," Lval

    ReturnExp =
      | "[" Exp CommaExp+ "]" Rec_Statement? -- multiple
      | Exp Rec_Statement? -- single

    CommaExp = "," Exp
    
    Exp =  BooleanExp

    BooleanExp =
      | BooleanExp boolNeq BooleanNot -- boolopneq
      | BooleanExp boolOp BooleanNot -- boolop
      | BooleanNot -- basic

    BooleanNot =
      | kw<"not"> BooleanExp -- not
      | AddExp -- basic

    AddExp =
      | AddExp "+" MulExp  -- plus
      | AddExp "-" MulExp  -- minus
      | MulExp -- basic

    MulExp =
      | MulExp "*" ExpExp  -- times
      | MulExp "/" ExpExp  -- divide
      | ExpExp -- basic

    ExpExp =
      | Primary "^" ExpExp  -- power
      | Primary -- basic

    Primary =
      | Primary "@" ident -- lookupident
      | Primary "@" Primary -- lookup
      | Primary "." ident -- field
      | Primary "[" Exp "]" -- index
      | Primary "[" digit+ ":" "]" -- nthslice
      | ident Actuals -- identcall
      | Primary Actuals -- call
      | Atom -- atom

    Atom =
      | "[" "]" -- emptylistconst
      | "{" "}" -- emptydict
      | "(" Exp ")" -- paren
      | "[" PrimaryComma+ "]" -- listconst
      | "{" PairComma+ "}" -- dict
      | "λ" LambdaFormals? ":" Exp -- lambda
      | kw<"fresh"> "(" ident ")" -- fresh
      | kw<"car"> "(" Exp ")" -- car
      | kw<"cdr"> "(" Exp ")" -- cdr
      | kw<"argvcdr"> "(" digit ")" -- nthargvcdr
      | kw<"nthargv"> "(" digit ")" -- nthargv
      | kw<"stringcdr"> "(" Exp ")" -- stringcdr
      | "+" Primary -- pos
      | "-" Primary -- neg
      | phi -- phi
      | "⊤" -- true
      | "⊥" -- false
      | kw<"range"> "(" Exp ")" -- range
      | string -- string
      | number -- number
      | ident -- ident



    PrimaryComma = Primary ","?
    PairComma = Pair ","?
    
    Lval = Exp





    keyword = (
        kw<"fresh">
      | kw<"defvar">
      | kw<"defconst">
      | kw<"defn">
      | kw<"defobj">
      | "•"
      | kw<"useglobal">
      | kw<"pass">
      | kw<"return">
      | kw<"if">
      | kw<"elif">
      | kw<"else">
      | kw<"and">
      | kw<"or">
      | kw<"in">
      | kw<"not">
      | kw<"range">
      | kw<"while">
      | kw<"f\"">
      | kw<"f'">
      | kw<"import">
      | kw<"try">
      | kw<"except">
      | kw<"as">
      | kw<"λ">
      | kw<"car">
      | kw<"cdr">
      | kw<"stringcdr">
      | kw<"argvcdr">
      | kw<"nthargv">
      )
      
    ident  = ~keyword identHead identTail*

    identHead = ( "_" | letter )
    identTail = ( alnum | identHead )

    Formals =
      | "(" ")" -- noformals
      | "(" Formal CommaFormal* ")" -- withformals
    ObjFormals =
      | "(" ")" -- noformals
      | "(" Formal CommaFormal* ")" -- withformals
    LambdaFormals =
      | "(" ")" -- noformals
      | "(" Formal CommaFormal* ")" -- withformals

    Formal = ident ("=" Exp)?
    CommaFormal = "," Formal
    
    Actuals = 
      | "(" ")" -- noactuals
      | "(" Actual CommaActual* ")" -- actuals

   Actual = ParamName? Exp
   CommaActual = "," Actual

   ParamName = ident "="

    number =
      | digit* "." digit+  -- fract
      | digit+             -- whole

    Pair = string ":" Exp ","?
  

  boolOp = (boolEq | boolNeq | "<=" | ">=" | ">" | "<" | kw<"and"> | kw<"or"> | kw<"in">)
  boolEq = "=="
  boolNeq = "!="

  phi = "ϕ"
  string =
    | "f\"" notdq* "\"" -- fdqstring
    | "f'" notsq* "'" -- fsqstring
    | "\"" notdq* "\"" -- dqstring
    | "'" notsq* "'" -- sqstring
  notdq = ~"\"" any
  notsq = ~"'" any


  comment = "#" notnl* nl
  nl = "\n"
  notnl = ~nl any
  space += comment
% parameter FunctionName

% rewrite

Main [ TopLevel+] = ‛«TopLevel»’

TopLevel_defvar [ Defvar] =‛«Defvar»’
TopLevel_defconst [ Defconst] =‛«Defconst»’
TopLevel_defn [ Defn] =‛«Defn»’
TopLevel_defobj [ Defclass] =‛«Defclass»’
TopLevel_import [ Import] =‛«Import»’
kw [ s] = ‛«s»’
Defvar [ __ lval _eq e] = ‛\n(defparameter «lval» «e»)’
Defconst [ __ lval _eq e] = ‛\n(defconstant «lval» «e»)’
Defn [ _4 ident Formals StatementBlock] =  
    ⎡ FunctionName=‛«ident»’
        ‛\n(defun «ident» «Formals»«StatementBlock»)’
    ⎦
Defobj [ _defobj ident Formals lb init+ rb] = ‛\n(defun new-«ident» «Formals»⤷\n(list⤷«init»⤶)⤶)\n’
Import [ _10 ident] = ‛\nimport «ident»’
StatementBlock [ _11 Statement _12] = ‛⤷\n(progn⤷«Statement»)⤶⤶’

Rec_Statement_globals [ _24 ident1  cidents* scope?] =‛\nglobal «ident1»«cidents»«scope»’
CommaIdent [_comma ident] = ‛, «ident»’
Rec_Statement_if [ IfStatement] =‛«IfStatement»’
Rec_Statement_pass [ _27 scope?] =‛\npass«scope»’
Rec_Statement_return [ _29 ReturnExp] =‛\n«ReturnExp»’
Rec_Statement_for [ ForStatement] =‛«ForStatement»’
Rec_Statement_while [ WhileStatement] =‛«WhileStatement»’
Rec_Statement_try [ TryStatement] =‛«TryStatement»’
Rec_Statement_assignment [ Assignment] =‛«Assignment»’
Rec_Statement_call [ Lval scope?] =‛\n«Lval»«scope»’
Rec_Statement_globals [ _24 ident1  cidents* scope?] =‛«scope»’

CommaIdent [_comma ident] = ‛ «ident»’

InitStatement [ _mark ident _33 Exp] = ‛\n(cons '«ident» «Exp»)’

IfStatement [ _35 Exp StatementBlock ElifStatement* ElseStatement? rec?] = ‛\n(cond ⤷\n(«Exp» «StatementBlock»)«ElifStatement»«ElseStatement»⤶)«rec»’
ElifStatement [ _37 Exp StatementBlock] = ‛\n(«Exp» «StatementBlock»)’
ElseStatement [ _39 StatementBlock] = ‛\n(t «StatementBlock»)’
ForStatement [ _41 ident _43 Exp StatementBlock rec?] = ‛\nfor «ident» in «Exp»:«StatementBlock»«rec»’
WhileStatement [ _45 Exp StatementBlock rec?] = ‛\nwhile «Exp»:«StatementBlock»«rec»’
TryStatement [ _47 StatementBlock ExceptBlock+ rec?] = ‛\ntry:\n«StatementBlock»«ExceptBlock»«rec»’

ExceptBlock_as [ _49 Exp _51 ident StatementBlock] =‛except «Exp» as «ident»:«StatementBlock»’
ExceptBlock_basic [ _53 ident StatementBlock] =‛except «ident»:«StatementBlock»’

Assignment_pluseq [ Lval _54 Exp rec?] = ‛\n(inc «Lval» «Exp»)«rec»’
Assignment_multiple [ _55 Lval1  Lval2+ _57 _58 Exp rec?] =‛\n(multiple-value-bind («Lval1» «Lval2»)⤷⤷\n«Exp»⤶«rec»⤶)’
Assignment_single [ Lval _59 Exp rec?] =‛\n(let («Lval» «Exp»)⤷«rec»⤶)’
CommaLval [_comma Lval] = ‛, «Lval»’

ReturnExp_multiple [ _60 Exp1 Exp2+ _62 rec?] =‛\n(return-from ⟪FunctionName⟫ (values «Exp1» «Exp2»))«rec»’
ReturnExp_single [ Exp rec?] =‛\n(return-from ⟪FunctionName⟫ «Exp»)«rec»’
CommaExp [_comma e] = ‛ «e»’
Exp [ BooleanExp] = ‛«BooleanExp»’

BooleanExp_boolopneq [ BooleanExp boolOp BooleanNot] =‛(not (equal «BooleanExp» «BooleanNot»))’
BooleanExp_boolop [ BooleanExp boolOp BooleanNot] =‛(«boolOp» «BooleanExp» «BooleanNot»)’
BooleanExp_basic [ BooleanNot] =‛«BooleanNot»’
boolEq [_eq] = ‛equal’
boolNeq [_neq] = ‛nequal’

BooleanNot_not [ _64 BooleanExp] =‛(not «BooleanExp»)’
BooleanNot_basic [ AddExp] =‛«AddExp»’

AddExp_plus [ AddExp _65 MulExp] =‛(+ «AddExp» «MulExp»)’
AddExp_minus [ AddExp _66 MulExp] =‛(- «AddExp» «MulExp»)’
AddExp_basic [ MulExp] =‛«MulExp»’

MulExp_times [ MulExp _67 ExpExp] =‛(* «MulExp» «ExpExp»)’
MulExp_divide [ MulExp _68 ExpExp] =‛(/ «MulExp» «ExpExp»)’
MulExp_basic [ ExpExp] =‛«ExpExp»’

ExpExp_power [ Primary _69 ExpExp] =‛(expt «Primary» «ExpExp»)’
ExpExp_basic [ Primary] =‛«Primary»’

Primary_lookupident [p _at key] = ‛(gethash '«key» «p»)’
Primary_lookup [p _at key] = ‛(gethash «key» «p»)’
Primary_field [p _dot key] = ‛(cdr (assoc '«key» «p»))’ 
Primary_index [p lb e rb] = ‛(aref «p» «e»)’ 
Primary_nthslice [p lb ds+ _colon rb] = ‛(nthcdr «ds» «p»)’
Primary_identcall [id actuals] = ‛(«id» «actuals»)’
Primary_call [p actuals] = ‛(funcall «p» «actuals»)’


Atom_emptylistconst [ _72 _73] =‛ nil’
Atom_emptydict [ _76 _77] =‛(make-hash-table :test :equal)’
Atom_paren [ _70 Exp _71] =‛ «Exp»’
Atom_listconst [ _74 PrimaryComma+ _75] =‛(list «PrimaryComma»)’
Atom_dict [ _78 PairComma+ _79] = ‛(fresh-hash (list «PairComma»))’
Atom_lambda [ _80 Formals? _81 Exp] =‛#'(lambda «Formals» «Exp»)’
Atom_fresh [ _83 _84 ident _85] =‛(fresh-«ident»)’
Atom_car [ _83 _84 e _85 ] =‛(car «e»)’
Atom_cdr [ _83 _84 e _85 ] =‛(cdr «e»)’
Atom_nthargvcdr [ _83 lb n rb ] =‛(nthcdr *argv* «n»)’
Atom_nthargv [ _83 _84 n _85 ] =‛(nth *argv* «n»)’
Atom_stringcdr [ _83 _84 e _85 ] =‛(subseq «e» 1)’
Atom_pos [ _86 Primary ] =‛(+ «Primary» 0)’
Atom_neg [ _87 Primary ] =‛(- 0 «Primary»)’
Atom_phi [ phi] =‛ nil’
Atom_true [ _88] =‛ t’
Atom_false [ _89] =‛ nil’
Atom_range [ _91 _92 Exp _93] =‛(loop for n from 0 below «Exp» by 1 collect n)’
Atom_string [ string] =‛«string»’
Atom_number [ number] =‛«number»’
Atom_ident [ ident ] =‛«ident»’

PrimaryComma [ Primary _94?] = ‛ «Primary»’
PairComma [ Pair _95?] = ‛ «Pair»’
Lval [ Exp ] = ‛«Exp»’
keyword [ _144] = ‛«_144»’
ident [ identHead identTail*] = ‛«identHead»«identTail»’
identHead [ _146] = ‛«_146»’
identTail [ _147] = ‛«_147»’

Formals_noformals [ _148 _149] =‛()’
Formals_withformals [ _150 Formal CommaFormal* _151] =‛(«Formal»«CommaFormal»)’
ObjFormals_noformals [ _148 _149] =‛()’
ObjFormals_withformals [ _150 Formal CommaFormal* _151] =‛(«Formal»«CommaFormal»)’
LambdaFormals_noformals [ _148 _149] =‛()’
LambdaFormals_withformals [ _150 Formal CommaFormal* _151] =‛(«Formal»«CommaFormal»)’
Formal [ ident  _152 Exp?] = ‛«ident»«_152»«Exp»’
CommaFormal [ _153 Formal] = ‛ «Formal»’

Actuals_noactuals [ _154 _155] = ‛’
Actuals_actuals [ _156 Actual CommaActual* _157] =‛«Actual»«CommaActual»’
Actual [ ParamName? Exp] = ‛ «ParamName»«Exp»’
CommaActual [ _158 Actual] = ‛ «Actual»’
ParamName [ ident _159] = ‛’

number_fract [ num* _160 den+] =‛«num».«den»’
number_whole [ digit+] =‛«digit»’
Pair [ string _161 Exp _162?] = ‛(«string» . «Exp»)’

boolOp [ _191] = ‛ «_191» ’
phi [ _192] = ‛ nil’

string_fdqstring [ _193 notdq* _194] =‛«_193»«notdq»«_194»’
string_fsqstring [ _195 notsq* _196] =‛«_195»«notsq»«_196»’
string_dqstring [ _197 notdq* _198] =‛«_197»«notdq»«_198»’
string_sqstring [ _199 notsq* _200] =‛«_199»«notsq»«_200»’
notdq [ any] = ‛«any»’
notsq [ any] = ‛«any»’
comment [ _203 notnl* nl] = ‛; «notnl»«nl»’
nl [ _204] = ‛«_204»’
notnl [ any] = ‛«any»’
space [ comment] = ‛«comment»’

