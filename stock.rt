defn probeA_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“?A”)
    return make_leaf (name_with_id, owner,  ϕ,  ↪︎probe_handler)
}

defn probeB_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol(“?B”)
    return make_leaf (name_with_id, owner,  ϕ,  ↪︎probe_handler)
}

defn probeC_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol(“?C”)
    return make_leaf (name_with_id, owner,  ϕ,  ↪︎probe_handler)
}

defn probe_handler (eh, msg) {
    s ≡ msg.datum.v
    #print_stderr (#strcons (“... probe ”, #strcons (eh.name, #strcons (“: ”, s))))
}

defn trash_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“trash”)
    return make_leaf (name_with_id, owner, ϕ, ↪︎trash_handler)
}

defn trash_handler (eh, msg) {
    ⌈ to appease dumped_on_floor checker⌉
    pass
}
defobj TwoMessages () {
        • firstmsg ⇐ ϕ
        • secondmsg ⇐ ϕ
}

⌈ Deracer_States :: enum { idle, waitingForFirstmsg, waitingForSecondmsg }⌉
defobj Deracer_Instance_Data () {
        • state ⇐ ϕ
        • buffer ⇐ ϕ
}

defn reclaim_Buffers_from_heap (inst) {
    pass
}

defn deracer_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“deracer”)
    deftemp inst ⇐ #fresh (Deracer_Instance_Data)
    inst.state ⇐ “idle”
    inst.buffer ⇐ #fresh (TwoMessages)
    eh ≡ make_leaf (name_with_id, owner, inst, ↪︎deracer_handler)
    return eh
}

defn send_firstmsg_then_secondmsg (eh, inst) {
    forward (eh, “1”, inst.buffer.firstmsg)
    forward (eh, “2”, inst.buffer.secondmsg)
    reclaim_Buffers_from_heap (inst)
}

defn deracer_handler (eh, msg) {
    deftemp inst ⇐ eh.instance_data
    if inst.state = “idle” {
        if “1” = msg.port {
            inst.buffer.firstmsg ⇐ msg
            inst.state ⇐ “waitingForSecondmsg”
        } elif “2” = msg.port {
            inst.buffer.secondmsg ⇐ msg
            inst.state ⇐ “waitingForFirstmsg”
        } else {
            runtime_error (#strcons (“bad msg.port (case A) for deracer ”, msg.port))
	}
    } elif inst.state = “waitingForFirstmsg” {
        if “1” = msg.port {
            inst.buffer.firstmsg ⇐ msg
            send_firstmsg_then_secondmsg (eh, inst)
            inst.state ⇐ “idle”
        } else {
            runtime_error (#strcons (“bad msg.port (case B) for deracer ”, msg.port))
	}
    } elif inst.state = “waitingForSecondmsg” {
        if “2” = msg.port {
            inst.buffer.secondmsg ⇐ msg
            send_firstmsg_then_secondmsg (eh, inst)
            inst.state ⇐ “idle”
        } else {
            runtime_error (#strcons (“bad msg.port (case C) for deracer ”, msg.port))
	}
    } else {
        runtime_error (“bad state for deracer {eh.state}”)
    }
}

defn low_level_read_text_file_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol(“Low Level Read Text File”)
    return make_leaf (name_with_id, owner, ϕ,  ↪︎low_level_read_text_file_handler)
}

defn low_level_read_text_file_handler (eh, msg) {
    fname ≡ msg.datum.v
    # low_level_read_text_file_handler (eh, msg, fname, “”, “✗”)
}

defn ensure_string_datum_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol(“Ensure String Datum”)
    return make_leaf (name_with_id, owner, ϕ, ↪︎ensure_string_datum_handler)
}

defn ensure_string_datum_handler (eh, msg) {
    if “string” = msg.datum.kind () {
        forward (eh, “”, msg)
    } else {
        emsg ≡ #strcons (“*** ensure: type error (expected a string datum) but got ”, msg.datum)
        send_string (eh, “✗”, emsg, msg)
    }
}

defobj Syncfilewrite_Data () {
        • filename ⇐ “”
}

⌈ temp copy for bootstrap, sends “done“ (error during bootstrap if not wired)⌉
defn syncfilewrite_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“syncfilewrite”)
    inst ≡ #fresh (Syncfilewrite_Data)
    return make_leaf (name_with_id, owner, inst, ↪︎syncfilewrite_handler)
}

defn syncfilewrite_handler (eh, msg) {
    deftemp inst ⇐ eh.instance_data
    if “filename” = msg.port {
        inst.filename ⇐ msg.datum.v
    } elif “input” = msg.port {
        contents ≡ msg.datum.v
        deftemp f ⇐ open (inst.filename, “w”)
        if f != ϕ {
            f.write (msg.datum.v)
            f.close ()
            send (eh, “done”, new_datum_bang (), msg)
        } else {
            send_string (eh, “✗”, #strcons (“open error on file ”, inst.filename), msg)
	}
    }
}

defobj StringConcat_Instance_Data () {
        • buffer1 ⇐ “”
        • buffer2 ⇐ “”
        • scount ⇐ 0
}

defn stringconcat_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“stringconcat”)
    instp ≡ #fresh (StringConcat_Instance_Data)
    return make_leaf (name_with_id, owner, instp, ↪︎stringconcat_handler)
}

defn stringconcat_handler (eh, msg) {
    deftemp inst ⇐ eh.instance_data
    if “1” = msg.port{
        inst.buffer1  ⇐ clone_string (msg.datum.v)
        inst.scount ⇐ inst.scount + 1
        maybe_stringconcat (eh, inst, msg)
    } elif “2” = msg.port {
        inst.buffer2 ⇐ clone_string (msg.datum.v)
        inst.scount ⇐ inst.scount + 1
        maybe_stringconcat (eh, inst, msg)
    } else {
        runtime_error (#strcons (“bad msg.port for stringconcat: ”, msg.port))
    }
}

defn maybe_stringconcat (eh, inst, msg) {
    if inst.scount >= 2 {
	deftemp concatenated_string ⇐ “”
	if 0 = #len (inst.buffer1) {
	    concatenated_string ⇐ inst.buffer2
	} elif 0 = #len (inst.buffer2) {
	    concatenated_string ⇐ inst.buffer1
	} else {
	    concatenated_string ⇐ inst.buffer1 + inst.buffer2
	}    
	send_string (eh, “”, concatenated_string, msg)
	inst.buffer1 ⇐ “”
	inst.buffer2 ⇐ “”
	inst.scount ⇐ 0
    }
}

⌈⌉

defn string_constant_instantiate (reg, owner, name, template_data) {
    global root_project
    global root_0D
    name_with_id ≡ gensymbol (“strconst”)
    deftemp s ⇐ template_data
    if root_project != “” {
        s ⇐ #substitute (“_00_”, root_project, s)
    }
    if root_0D != “” {
        s ⇐ #substitute (“_0D_”, root_0D, s)
    }
    return make_leaf (name_with_id, owner, s, ↪︎string_constant_handler)
}

defn string_constant_handler (eh, msg) {
    s ≡ eh.instance_data
    send_string (eh, “”, s, msg)
}
