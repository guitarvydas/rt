defn log_forward (sender, sender_port, msg, cause_msg) {
    pass ⌈ when needed, it is too frequent to bother logging⌉
}

defn fmt_forward (desc) {
    print (strcons (“*** Error fmt_forward ”, desc))
    quit ()
}

⌈⌉
defn make_Inject_Descriptor (receiver, port, message) {
    rdesc ≡ make_Routing_Descriptor (action ∷ drInject, component ∷ receiver, port ∷ port, message ∷ message)
    return {
        “action”: drInject,
        “component”: rdesc@component,
        “port”: rdesc@port,
        “message”: rdesc@message,
        “fmt” : fmt_inject
        }
}

defn log_inject (receiver, port, msg) {
    inject_desc ≡ make_Inject_Descriptor (receiver ∷ receiver, port ∷ port, message ∷ msg)
    append_routing_descriptor (container ∷ receiver, desc ∷ inject_desc)
}

defn fmt_inject (desc, indent) {
    ⌈return f'\n{indent}⟹  {desc@component.name}.“{desc@port}“ {format_message (desc@message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“⟹  ”,
	         strcons (desc@component.name,
		   strcons (“.”,
		     strcons (desc@port,
		       strcons (“ ”, format_message (desc@message))))))))
}

⌈⌉
defn make_Down_Descriptor (container, source_port, source_message, target, target_port, target_message) {
    return {
        “action”: drDown,
        “container”: container,
        “source_port”: source_port,
        “source_message”: source_message,
        “target”: target,
        “target_port”: target_port,
        “target_message”: target_message,
        “fmt” : fmt_down
        }
}

defn log_down (container, source_port, source_message, target, target_port, target_message) {
    rdesc ≡ make_Down_Descriptor (container, source_port, source_message, target, target_port, target_message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_down (desc, indent) {
    ⌈return f'\n{indent}↓ {desc@container.name}.“{desc@source_port}“ ➔ {desc@target.name}.“{desc@target_port}“ {format_message (desc@target_message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“ ↓ ”,
	         strcons (desc@container.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@target.name,
			   strcons (“.”,
			     strcons (desc@target_port,
			       strcons (“ ”, format_message (desc@target_message))))))))))))
}

⌈⌉
defn make_Up_Descriptor (source, source_port, source_message, container, container_port, container_message) {
    return {
        “action”: drUp,
        “source”: source,
        “source_port”: source_port,
        “source_message”: source_message,
        “container”: container,
        “container_port”: container_port,
        “container_message”: container_message,
        “fmt” : fmt_up
        }
}

defn log_up (source, source_port, source_message, container, target_port, target_message) {
    rdesc ≡ make_Up_Descriptor (source, source_port, source_message, container, target_port, target_message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_up (desc, indent) {
    ⌈return f'\n{indent}↑ {desc@source.name}.“{desc@source_port}“ ➔ {desc@container.name}.“{desc@container_port}“ {format_message (desc@container_message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“↑ ”,
	         strcons (desc@source.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@container.name,
			   strcons (“.”,
			     strcons (desc@container_port,
			       strcons (“ ”, format_message (desc@container_message))))))))))))
}

defn make_Across_Descriptor (container, source, source_port, source_message, target, target_port, target_message) {
    return {
        “action”: drAcross,
        “container”: container,
        “source”: source,
        “source_port”: source_port,
        “source_message”: source_message,
        “target”: target,
        “target_port”: target_port,
        “target_message”: target_message,
        “fmt” : fmt_across
        }
}

defn log_across (container, source, source_port, source_message, target, target_port, target_message) {
    rdesc ≡ make_Across_Descriptor (container, source, source_port, source_message, target, target_port, target_message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_across (desc, indent) {
    ⌈return f'\n{indent}→ {desc@source.name}.“{desc@source_port}“ ➔ {desc@target.name}.“{desc@target_port}“  {format_message (desc@target_message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“→ ”,
	         strcons (desc@source.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@target.name,
			   strcons (“.”,
			     strcons (desc@target_port,
			       strcons (“  ”, format_message (desc@target_message))))))))))))
}

⌈⌉
defn make_Through_Descriptor (container, source_port, source_message, target_port, message) {
    return {
        “action”: drThrough,
        “container”: container,
        “source_port”: source_port,
        “source_message”: source_message,
        “target_port”: target_port,
        “message”: message,
        “fmt” : fmt_through
        }
}

defn log_through (container, source_port, source_message, target_port, message) {
    rdesc ≡ make_Through_Descriptor (container, source_port, source_message, target_port, message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_through (desc, indent) {
    ⌈return f'\n{indent}⇶ {desc @container.name}.“{desc@source_port}“ ➔ {desc@container.name}.“{desc@target_port}“ {format_message (desc@message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“⇶ ”,
	         strcons (desc@container.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@container.name,
			   strcons (“.”,
			     strcons (desc@target_port,
			       strcons (“ ”, format_message (desc@message))))))))))))
}

⌈⌉
defn make_InOut_Descriptor (container, component, in_message, out_port, out_message) {
    return {
        “action”: drInOut,
        “container”: container,
        “component”: component,
        “in_message”: in_message,
        “out_message”: out_message,
        “fmt” : fmt_inout
        }
}

defn log_inout (container, component, in_message) {
    if component.outq.empty () {
        log_inout_no_output (container ∷ container, component ∷ component, in_message ∷ in_message) }
    else {
        log_inout_recursively (container ∷ container, component ∷ component, in_message ∷ in_message, out_messages ∷ list (component.outq.queue)) }
}
