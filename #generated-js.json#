{
    "javascript":
    "let  count_counter =  0;                               /* line 1 */\nlet  count_direction =  1;                             /* line 2 *//* line 3 */\nfunction count_handler (eh,msg) {                      /* line 4 *//* line 5 */\n    if ( msg.port ==  \"adv\") {                         /* line 6 */\n      count_counter =  count_counter+ count_direction; /* line 7 */\n      send_int ( eh, \"\", count_counter, msg)           /* line 8 */}\n    else if ( msg.port ==  \"rev\") {                    /* line 9 */\n      count_direction = (- count_direction)            /* line 10 */;/* line 11 */}/* line 12 *//* line 13 */\n}\n\nfunction count_instantiator (reg,owner,name,template_data) {/* line 14 */\n    let name_with_id = gensymbol ( \"Count\")            /* line 15 */;\n    return make_leaf ( name_with_id, owner, null, count_handler)/* line 16 */;/* line 17 *//* line 18 */\n}\n\nfunction count_install (reg) {                         /* line 19 */\n    register_component ( reg,mkTemplate ( \"Count\", null, count_instantiator))/* line 20 *//* line 21 */\n}function monitor_install (reg) {                       /* line 1 */\n    register_component ( reg,mkTemplate ( \"@\", null, monitor_instantiator))/* line 2 *//* line 3 *//* line 4 */\n}\n\nfunction monitor_instantiator (reg,owner,name,template_data) {/* line 5 */\n    let name_with_id = gensymbol ( \"@\")                /* line 6 */;\n    return make_leaf ( name_with_id, owner, null, monitor_handler)/* line 7 */;/* line 8 *//* line 9 */\n}\n\nfunction monitor_handler (eh,msg) {                    /* line 10 */\n    let  s =  msg.datum.v;                             /* line 11 */\n    let  i = Number ( s)                               /* line 12 */;\n    while ( i >  0) {                                  /* line 13 */\n      s =  `${ \" \"}${ s}`                              /* line 14 */;\n      i =  i- 1;                                       /* line 15 *//* line 16 */}\n    console.log ( s);                                  /* line 17 *//* line 18 */\n}function decode_install (reg) {                        /* line 1 */\n    register_component ( reg,mkTemplate ( \"Decode\", null, decode_instantiator))/* line 2 *//* line 3 *//* line 4 */\n}\n\nfunction decode_handler (eh,msg) {                     /* line 5 *//* line 6 */\n    let s =  msg.datum.v;                              /* line 7 */\n    let  i = Number ( s)                               /* line 8 */;\n    if ((( i >=  0) && ( i <=  9))) {                  /* line 9 */\n      send_string ( eh, s, s, msg)                     /* line 10 *//* line 11 */}\n    send_bang ( eh, \"done\", msg)                       /* line 12 *//* line 13 *//* line 14 */\n}\n\nfunction decode_instantiator (reg,owner,name,template_data) {/* line 15 */\n    let name_with_id = gensymbol ( \"Decode\")           /* line 16 */;\n    return make_leaf ( name_with_id, owner, null, decode_handler)/* line 17 */;\n}function reverser_install (reg) {                      /* line 1 */\n    register_component ( reg,mkTemplate ( \"Reverser\", null, reverser_instantiator))/* line 2 *//* line 3 *//* line 4 */\n}\n\nlet  reverser_state =  \"J\";                            /* line 5 *//* line 6 */\nfunction reverser_handler (eh,msg) {                   /* line 7 *//* line 8 */\n    if ( reverser_state ==  \"K\") {                     /* line 9 */\n      if ( msg.port ==  \"J\") {                         /* line 10 */\n        send_bang ( eh, \"\", msg)                       /* line 11 */\n        reverser_state =  \"J\";                         /* line 12 */}\n      else {                                           /* line 13 *//* line 14 *//* line 15 */}}\n    else if ( reverser_state ==  \"J\") {                /* line 16 */\n      if ( msg.port ==  \"K\") {                         /* line 17 */\n        send_bang ( eh, \"\", msg)                       /* line 18 */\n        reverser_state =  \"K\";                         /* line 19 */}\n      else {                                           /* line 20 *//* line 21 *//* line 22 */}/* line 23 */}/* line 24 *//* line 25 */\n}\n\nfunction reverser_instantiator (reg,owner,name,template_data) {/* line 26 */\n    let name_with_id = gensymbol ( \"Reverser\")         /* line 27 */;\n    return make_leaf ( name_with_id, owner, null, reverser_handler)/* line 28 */;/* line 29 */\n}function delay_install (reg) {                         /* line 1 */\n    register_component ( reg,mkTemplate ( \"Delay\", null, delay_instantiator))/* line 2 *//* line 3 *//* line 4 */\n}\n\nclass Delay_Info {\n  constructor () {                                     /* line 5 */\n\n    this.counter =  0;                                 /* line 6 */\n    this.saved_message =  null;                        /* line 7 *//* line 8 */\n  }\n}\n                                                       /* line 9 */\nfunction delay_instantiator (reg,owner,name,template_data) {/* line 10 */\n    let name_with_id = gensymbol ( \"delay\")            /* line 11 */;\n    let info =  new Delay_Info ();                     /* line 12 */;\n    return make_leaf ( name_with_id, owner, info, delay_handler)/* line 13 */;/* line 14 *//* line 15 */\n}\n\nlet  DELAYDELAY =  5000;                               /* line 16 *//* line 17 */\nfunction first_time (m) {                              /* line 18 */\n    return (! is_tick ( m)                             /* line 19 */);/* line 20 *//* line 21 */\n}\n\nfunction delay_handler (eh,msg) {                      /* line 22 */\n    let info =  eh.instance_data;                      /* line 23 */\n    if (first_time ( msg)) {                           /* line 24 */\n      info.saved_message =  msg;                       /* line 25 */\n      set_active ( eh)\n      /*  tell engine to keep running this component with ;ticks'  *//* line 26 *//* line 27 */}/* line 28 */\n    let count =  info.counter;                         /* line 29 */\n    let  next =  count+ 1;                             /* line 30 */\n    if ( info.counter >=  DELAYDELAY) {                /* line 31 */\n      set_idle ( eh)\n      /*  tell engine that we're finally done  */      /* line 32 */\n      forward ( eh, \"\", info.saved_message)            /* line 33 */\n      next =  0;                                       /* line 34 *//* line 35 */}\n    info.counter =  next;                              /* line 36 *//* line 37 *//* line 38 */\n}function probeA_instantiate (reg,owner,name,template_data) {/* line 1 */\n    let name_with_id = gensymbol ( \"?A\")               /* line 2 */;\n    return make_leaf ( name_with_id, owner, null, probe_handler)/* line 3 */;/* line 4 *//* line 5 */\n}\n\nfunction probeB_instantiate (reg,owner,name,template_data) {/* line 6 */\n    let name_with_id = gensymbol ( \"?B\")               /* line 7 */;\n    return make_leaf ( name_with_id, owner, null, probe_handler)/* line 8 */;/* line 9 *//* line 10 */\n}\n\nfunction probeC_instantiate (reg,owner,name,template_data) {/* line 11 */\n    let name_with_id = gensymbol ( \"?C\")               /* line 12 */;\n    return make_leaf ( name_with_id, owner, null, probe_handler)/* line 13 */;/* line 14 *//* line 15 */\n}\n\nfunction probe_handler (eh,msg) {                      /* line 16 */\n    let s =  msg.datum.v;                              /* line 17 */\n    console.error ( `${ \"... probe \"}${ `${ eh.name}${ `${ \": \"}${ s}` }` }` );/* line 18 *//* line 19 *//* line 20 */\n}\n\nfunction trash_instantiate (reg,owner,name,template_data) {/* line 21 */\n    let name_with_id = gensymbol ( \"trash\")            /* line 22 */;\n    return make_leaf ( name_with_id, owner, null, trash_handler)/* line 23 */;/* line 24 *//* line 25 */\n}\n\nfunction trash_handler (eh,msg) {                      /* line 26 */\n    /*  to appease dumped_on_floor checker */          /* line 27 *//* line 28 *//* line 29 */\n}\n\nclass TwoMessages {\n  constructor () {                                     /* line 30 */\n\n    this.firstmsg =  null;                             /* line 31 */\n    this.secondmsg =  null;                            /* line 32 *//* line 33 */\n  }\n}\n                                                       /* line 34 */\n/*  Deracer_States :: enum { idle, waitingForFirstmsg, waitingForSecondmsg } *//* line 35 */\nclass Deracer_Instance_Data {\n  constructor () {                                     /* line 36 */\n\n    this.state =  null;                                /* line 37 */\n    this.buffer =  null;                               /* line 38 *//* line 39 */\n  }\n}\n                                                       /* line 40 */\nfunction reclaim_Buffers_from_heap (inst) {            /* line 41 *//* line 42 *//* line 43 *//* line 44 */\n}\n\nfunction deracer_instantiate (reg,owner,name,template_data) {/* line 45 */\n    let name_with_id = gensymbol ( \"deracer\")          /* line 46 */;\n    let  inst =  new Deracer_Instance_Data ();         /* line 47 */;\n    inst.state =  \"idle\";                              /* line 48 */\n    inst.buffer =  new TwoMessages ();                 /* line 49 */;\n    let eh = make_leaf ( name_with_id, owner, inst, deracer_handler)/* line 50 */;\n    return  eh;                                        /* line 51 *//* line 52 *//* line 53 */\n}\n\nfunction send_firstmsg_then_secondmsg (eh,inst) {      /* line 54 */\n    forward ( eh, \"1\", inst.buffer.firstmsg)           /* line 55 */\n    forward ( eh, \"2\", inst.buffer.secondmsg)          /* line 56 */\n    reclaim_Buffers_from_heap ( inst)                  /* line 57 *//* line 58 *//* line 59 */\n}\n\nfunction deracer_handler (eh,msg) {                    /* line 60 */\n    let  inst =  eh.instance_data;                     /* line 61 */\n    if ( inst.state ==  \"idle\") {                      /* line 62 */\n      if ( \"1\" ==  msg.port) {                         /* line 63 */\n        inst.buffer.firstmsg =  msg;                   /* line 64 */\n        inst.state =  \"waitingForSecondmsg\";           /* line 65 */}\n      else if ( \"2\" ==  msg.port) {                    /* line 66 */\n        inst.buffer.secondmsg =  msg;                  /* line 67 */\n        inst.state =  \"waitingForFirstmsg\";            /* line 68 */}\n      else {                                           /* line 69 */\n        runtime_error ( `${ \"bad msg.port (case A) for deracer \"}${ msg.port}` )/* line 70 *//* line 71 */}}\n    else if ( inst.state ==  \"waitingForFirstmsg\") {   /* line 72 */\n      if ( \"1\" ==  msg.port) {                         /* line 73 */\n        inst.buffer.firstmsg =  msg;                   /* line 74 */\n        send_firstmsg_then_secondmsg ( eh, inst)       /* line 75 */\n        inst.state =  \"idle\";                          /* line 76 */}\n      else {                                           /* line 77 */\n        runtime_error ( `${ \"bad msg.port (case B) for deracer \"}${ msg.port}` )/* line 78 *//* line 79 */}}\n    else if ( inst.state ==  \"waitingForSecondmsg\") {  /* line 80 */\n      if ( \"2\" ==  msg.port) {                         /* line 81 */\n        inst.buffer.secondmsg =  msg;                  /* line 82 */\n        send_firstmsg_then_secondmsg ( eh, inst)       /* line 83 */\n        inst.state =  \"idle\";                          /* line 84 */}\n      else {                                           /* line 85 */\n        runtime_error ( `${ \"bad msg.port (case C) for deracer \"}${ msg.port}` )/* line 86 *//* line 87 */}}\n    else {                                             /* line 88 */\n      runtime_error ( \"bad state for deracer {eh.state}\")/* line 89 *//* line 90 */}/* line 91 *//* line 92 */\n}\n\nfunction low_level_read_text_file_instantiate (reg,owner,name,template_data) {/* line 93 */\n    let name_with_id = gensymbol ( \"Low Level Read Text File\")/* line 94 */;\n    return make_leaf ( name_with_id, owner, null, low_level_read_text_file_handler)/* line 95 */;/* line 96 *//* line 97 */\n}\n\nfunction low_level_read_text_file_handler (eh,msg) {   /* line 98 */\n    let fname =  msg.datum.v;                          /* line 99 */\n\n    if (fname == \"0\") {\n    data = fs.readFileSync (0);\n    } else {\n    data = fs.readFileSync (fname);\n    }\n    if (data) {\n      send_string (eh, \"\", data, msg);\n    } else {\n      send_string (eh, \"✗\", `read error on file '${fname}'`, msg);\n    }\n                                                       /* line 100 *//* line 101 *//* line 102 */\n}\n\nfunction ensure_string_datum_instantiate (reg,owner,name,template_data) {/* line 103 */\n    let name_with_id = gensymbol ( \"Ensure String Datum\")/* line 104 */;\n    return make_leaf ( name_with_id, owner, null, ensure_string_datum_handler)/* line 105 */;/* line 106 *//* line 107 */\n}\n\nfunction ensure_string_datum_handler (eh,msg) {        /* line 108 */\n    if ( \"string\" ==  msg.datum.kind ()) {             /* line 109 */\n      forward ( eh, \"\", msg)                           /* line 110 */}\n    else {                                             /* line 111 */\n      let emsg =  `${ \"*** ensure: type error (expected a string datum) but got \"}${ msg.datum}` /* line 112 */;\n      send_string ( eh, \"✗\", emsg, msg)                /* line 113 *//* line 114 */}/* line 115 *//* line 116 */\n}\n\nclass Syncfilewrite_Data {\n  constructor () {                                     /* line 117 */\n\n    this.filename =  \"\";                               /* line 118 *//* line 119 */\n  }\n}\n                                                       /* line 120 */\n/*  temp copy for bootstrap, sends “done“ (error during bootstrap if not wired) *//* line 121 */\nfunction syncfilewrite_instantiate (reg,owner,name,template_data) {/* line 122 */\n    let name_with_id = gensymbol ( \"syncfilewrite\")    /* line 123 */;\n    let inst =  new Syncfilewrite_Data ();             /* line 124 */;\n    return make_leaf ( name_with_id, owner, inst, syncfilewrite_handler)/* line 125 */;/* line 126 *//* line 127 */\n}\n\nfunction syncfilewrite_handler (eh,msg) {              /* line 128 */\n    let  inst =  eh.instance_data;                     /* line 129 */\n    if ( \"filename\" ==  msg.port) {                    /* line 130 */\n      inst.filename =  msg.datum.v;                    /* line 131 */}\n    else if ( \"input\" ==  msg.port) {                  /* line 132 */\n      let contents =  msg.datum.v;                     /* line 133 */\n      let  f = open ( inst.filename, \"w\")              /* line 134 */;\n      if ( f!= null) {                                 /* line 135 */\n        f.write ( msg.datum.v)                         /* line 136 */\n        f.close ()                                     /* line 137 */\n        send ( eh, \"done\",new_datum_bang (), msg)      /* line 138 */}\n      else {                                           /* line 139 */\n        send_string ( eh, \"✗\", `${ \"open error on file \"}${ inst.filename}` , msg)/* line 140 *//* line 141 */}/* line 142 */}/* line 143 *//* line 144 */\n}\n\nclass StringConcat_Instance_Data {\n  constructor () {                                     /* line 145 */\n\n    this.buffer1 =  null;                              /* line 146 */\n    this.buffer2 =  null;                              /* line 147 */\n    this.scount =  0;                                  /* line 148 *//* line 149 */\n  }\n}\n                                                       /* line 150 */\nfunction stringconcat_instantiate (reg,owner,name,template_data) {/* line 151 */\n    let name_with_id = gensymbol ( \"stringconcat\")     /* line 152 */;\n    let instp =  new StringConcat_Instance_Data ();    /* line 153 */;\n    return make_leaf ( name_with_id, owner, instp, stringconcat_handler)/* line 154 */;/* line 155 *//* line 156 */\n}\n\nfunction stringconcat_handler (eh,msg) {               /* line 157 */\n    let  inst =  eh.instance_data;                     /* line 158 */\n    if ( \"1\" ==  msg.port) {                           /* line 159 */\n      inst.buffer1 = clone_string ( msg.datum.v)       /* line 160 */;\n      inst.scount =  inst.scount+ 1;                   /* line 161 */\n      maybe_stringconcat ( eh, inst, msg)              /* line 162 */}\n    else if ( \"2\" ==  msg.port) {                      /* line 163 */\n      inst.buffer2 = clone_string ( msg.datum.v)       /* line 164 */;\n      inst.scount =  inst.scount+ 1;                   /* line 165 */\n      maybe_stringconcat ( eh, inst, msg)              /* line 166 */}\n    else {                                             /* line 167 */\n      runtime_error ( `${ \"bad msg.port for stringconcat: \"}${ msg.port}` )/* line 168 *//* line 169 */}/* line 170 *//* line 171 */\n}\n\nfunction maybe_stringconcat (eh,inst,msg) {            /* line 172 */\n    if ( inst.scount >=  2) {                          /* line 173 */\n      if (((( 0 == ( inst.buffer1.length))) && (( 0 == ( inst.buffer2.length))))) {/* line 174 */\n        runtime_error ( \"something is wrong in stringconcat, both strings are 0 length\")/* line 175 */}\n      else {                                           /* line 176 */\n        let  concatenated_string =  \"\";                /* line 177 */\n        if ( 0 == ( inst.buffer1.length)) {            /* line 178 */\n          concatenated_string =  inst.buffer2;         /* line 179 */}\n        else if ( 0 == ( inst.buffer2.length)) {       /* line 180 */\n          concatenated_string =  inst.buffer1;         /* line 181 */}\n        else {                                         /* line 182 */\n          concatenated_string =  inst.buffer1+ inst.buffer2;/* line 183 *//* line 184 */}\n        send_string ( eh, \"\", concatenated_string, msg)/* line 185 */\n        inst.buffer1 =  null;                          /* line 186 */\n        inst.buffer2 =  null;                          /* line 187 */\n        inst.scount =  0;                              /* line 188 *//* line 189 */}/* line 190 */}/* line 191 *//* line 192 */\n}\n\n/*  */                                                 /* line 193 *//* line 194 */\nfunction string_constant_instantiate (reg,owner,name,template_data) {/* line 195 *//* line 196 *//* line 197 */\n    let name_with_id = gensymbol ( \"strconst\")         /* line 198 */;\n    let  s =  template_data;                           /* line 199 */\n    if ( root_project!= \"\") {                          /* line 200 */\n      s =  s.replaceAll ( \"_00_\",  root_project)       /* line 201 */;/* line 202 */}\n    if ( root_0D!= \"\") {                               /* line 203 */\n      s =  s.replaceAll ( \"_0D_\",  root_0D)            /* line 204 */;/* line 205 */}\n    return make_leaf ( name_with_id, owner, s, string_constant_handler)/* line 206 */;/* line 207 *//* line 208 */\n}\n\nfunction string_constant_handler (eh,msg) {            /* line 209 */\n    let s =  eh.instance_data;                         /* line 210 */\n    send_string ( eh, \"\", s, msg)                      /* line 211 *//* line 212 *//* line 213 */\n}\n\nfunction fakepipename_instantiate (reg,owner,name,template_data) {/* line 214 */\n    let instance_name = gensymbol ( \"fakepipe\")        /* line 215 */;\n    return make_leaf ( instance_name, owner, null, fakepipename_handler)/* line 216 */;/* line 217 *//* line 218 */\n}\n\nlet  rand =  0;                                        /* line 219 *//* line 220 */\nfunction fakepipename_handler (eh,msg) {               /* line 221 *//* line 222 */\n    rand =  rand+ 1;\n    /*  not very random, but good enough _ ;rand' must be unique within a single run *//* line 223 */\n    send_string ( eh, \"\", `${ \"/tmp/fakepipe\"}${ rand}` , msg)/* line 224 *//* line 225 *//* line 226 */\n}\n                                                       /* line 227 */\nclass Switch1star_Instance_Data {\n  constructor () {                                     /* line 228 */\n\n    this.state =  \"1\";                                 /* line 229 *//* line 230 */\n  }\n}\n                                                       /* line 231 */\nfunction switch1star_instantiate (reg,owner,name,template_data) {/* line 232 */\n    let name_with_id = gensymbol ( \"switch1*\")         /* line 233 */;\n    let instp =  new Switch1star_Instance_Data ();     /* line 234 */;\n    return make_leaf ( name_with_id, owner, instp, switch1star_handler)/* line 235 */;/* line 236 *//* line 237 */\n}\n\nfunction switch1star_handler (eh,msg) {                /* line 238 */\n    let  inst =  eh.instance_data;                     /* line 239 */\n    let whichOutput =  inst.state;                     /* line 240 */\n    if ( \"\" ==  msg.port) {                            /* line 241 */\n      if ( \"1\" ==  whichOutput) {                      /* line 242 */\n        forward ( eh, \"1\", msg)                        /* line 243 */\n        inst.state =  \"*\";                             /* line 244 */}\n      else if ( \"*\" ==  whichOutput) {                 /* line 245 */\n        forward ( eh, \"*\", msg)                        /* line 246 */}\n      else {                                           /* line 247 */\n        send ( eh, \"✗\", \"internal error bad state in switch1*\", msg)/* line 248 *//* line 249 */}}\n    else if ( \"reset\" ==  msg.port) {                  /* line 250 */\n      inst.state =  \"1\";                               /* line 251 */}\n    else {                                             /* line 252 */\n      send ( eh, \"✗\", \"internal error bad message for switch1*\", msg)/* line 253 *//* line 254 */}/* line 255 *//* line 256 */\n}\n\nclass Latch_Instance_Data {\n  constructor () {                                     /* line 257 */\n\n    this.datum =  null;                                /* line 258 *//* line 259 */\n  }\n}\n                                                       /* line 260 */\nfunction latch_instantiate (reg,owner,name,template_data) {/* line 261 */\n    let name_with_id = gensymbol ( \"latch\")            /* line 262 */;\n    let instp =  new Latch_Instance_Data ();           /* line 263 */;\n    return make_leaf ( name_with_id, owner, instp, latch_handler)/* line 264 */;/* line 265 *//* line 266 */\n}\n\nfunction latch_handler (eh,msg) {                      /* line 267 */\n    let  inst =  eh.instance_data;                     /* line 268 */\n    if ( \"\" ==  msg.port) {                            /* line 269 */\n      inst.datum =  msg.datum;                         /* line 270 */}\n    else if ( \"release\" ==  msg.port) {                /* line 271 */\n      let  d =  inst.datum;                            /* line 272 */\n      send ( eh, \"\", d, msg)                           /* line 273 */\n      inst.datum =  null;                              /* line 274 */}\n    else {                                             /* line 275 */\n      send ( eh, \"✗\", \"internal error bad message for latch\", msg)/* line 276 *//* line 277 */}/* line 278 *//* line 279 */\n}\n\n/*  all of the the built_in leaves are listed here */  /* line 280 */\n/*  future: refactor this such that programmers can pick and choose which (lumps of) builtins are used in a specific project *//* line 281 *//* line 282 */\nfunction initialize_stock_components (reg) {           /* line 283 */\n    register_component ( reg,mkTemplate ( \"1then2\", null, deracer_instantiate))/* line 284 */\n    register_component ( reg,mkTemplate ( \"?A\", null, probeA_instantiate))/* line 285 */\n    register_component ( reg,mkTemplate ( \"?B\", null, probeB_instantiate))/* line 286 */\n    register_component ( reg,mkTemplate ( \"?C\", null, probeC_instantiate))/* line 287 */\n    register_component ( reg,mkTemplate ( \"trash\", null, trash_instantiate))/* line 288 *//* line 289 */\n    register_component ( reg,mkTemplate ( \"Low Level Read Text File\", null, low_level_read_text_file_instantiate))/* line 290 */\n    register_component ( reg,mkTemplate ( \"Ensure String Datum\", null, ensure_string_datum_instantiate))/* line 291 *//* line 292 */\n    register_component ( reg,mkTemplate ( \"syncfilewrite\", null, syncfilewrite_instantiate))/* line 293 */\n    register_component ( reg,mkTemplate ( \"stringconcat\", null, stringconcat_instantiate))/* line 294 */\n    register_component ( reg,mkTemplate ( \"switch1*\", null, switch1star_instantiate))/* line 295 */\n    register_component ( reg,mkTemplate ( \"latch\", null, latch_instantiate))/* line 296 */\n    /*  for fakepipe */                                /* line 297 */\n    register_component ( reg,mkTemplate ( \"fakepipename\", null, fakepipename_instantiate))/* line 298 *//* line 299 */\n}import * as fs from 'fs';\nimport path from 'path';\nconst command_line_argv = process.argv.slice(1);\nimport execSync from 'child_process';\n                                                       /* line 1 *//* line 2 */\nlet  counter =  0;                                     /* line 3 *//* line 4 */\nlet  digits = [ \"₀\", \"₁\", \"₂\", \"₃\", \"₄\", \"₅\", \"₆\", \"₇\", \"₈\", \"₉\", \"₁₀\", \"₁₁\", \"₁₂\", \"₁₃\", \"₁₄\", \"₁₅\", \"₁₆\", \"₁₇\", \"₁₈\", \"₁₉\", \"₂₀\", \"₂₁\", \"₂₂\", \"₂₃\", \"₂₄\", \"₂₅\", \"₂₆\", \"₂₇\", \"₂₈\", \"₂₉\"];/* line 11 *//* line 12 *//* line 13 */\nfunction gensymbol (s) {                               /* line 14 *//* line 15 */\n    let name_with_id =  `${ s}${subscripted_digit ( counter)}` /* line 16 */;\n    counter =  counter+ 1;                             /* line 17 */\n    return  name_with_id;                              /* line 18 *//* line 19 *//* line 20 */\n}\n\nfunction subscripted_digit (n) {                       /* line 21 *//* line 22 */\n    if (((( n >=  0) && ( n <=  29)))) {               /* line 23 */\n      return  digits [ n];                             /* line 24 */}\n    else {                                             /* line 25 */\n      return  `${ \"₊\"}${`${ n}`}`                      /* line 26 */;/* line 27 */}/* line 28 *//* line 29 */\n}\n\nclass Datum {\n  constructor () {                                     /* line 30 */\n\n    this.v =  null;                                    /* line 31 */\n    this.clone =  null;                                /* line 32 */\n    this.reclaim =  null;                              /* line 33 */\n    this.other =  null;/*  reserved for use on per-project basis  *//* line 34 *//* line 35 */\n  }\n}\n                                                       /* line 36 */\nfunction new_datum_string (s) {                        /* line 37 */\n    let d =  new Datum ();                             /* line 38 */;\n    d.v =  s;                                          /* line 39 */\n    d.clone =  function () {return clone_datum_string ( d)/* line 40 */;};\n    d.reclaim =  function () {return reclaim_datum_string ( d)/* line 41 */;};\n    return  d;                                         /* line 42 *//* line 43 *//* line 44 */\n}\n\nfunction clone_datum_string (d) {                      /* line 45 */\n    let newd = new_datum_string ( d.v)                 /* line 46 */;\n    return  newd;                                      /* line 47 *//* line 48 *//* line 49 */\n}\n\nfunction reclaim_datum_string (src) {                  /* line 50 *//* line 51 *//* line 52 *//* line 53 */\n}\n\nfunction new_datum_bang () {                           /* line 54 */\n    let p =  new Datum ();                             /* line 55 */;\n    p.v =  \"\";                                         /* line 56 */\n    p.clone =  function () {return clone_datum_bang ( p)/* line 57 */;};\n    p.reclaim =  function () {return reclaim_datum_bang ( p)/* line 58 */;};\n    return  p;                                         /* line 59 *//* line 60 *//* line 61 */\n}\n\nfunction clone_datum_bang (d) {                        /* line 62 */\n    return new_datum_bang ();                          /* line 63 *//* line 64 *//* line 65 */\n}\n\nfunction reclaim_datum_bang (d) {                      /* line 66 *//* line 67 *//* line 68 *//* line 69 */\n}\n\n/*  Message passed to a leaf component. */             /* line 70 */\n/*  */                                                 /* line 71 */\n/*  `port` refers to the name of the incoming or outgoing port of this component. *//* line 72 */\n/*  `datum` is the data attached to this message. */   /* line 73 */\nclass Message {\n  constructor () {                                     /* line 74 */\n\n    this.port =  null;                                 /* line 75 */\n    this.datum =  null;                                /* line 76 *//* line 77 */\n  }\n}\n                                                       /* line 78 */\nfunction clone_port (s) {                              /* line 79 */\n    return clone_string ( s)                           /* line 80 */;/* line 81 *//* line 82 */\n}\n\n/*  Utility for making a `Message`. Used to safely “seed“ messages *//* line 83 */\n/*  entering the very top of a network. */             /* line 84 */\nfunction make_message (port,datum) {                   /* line 85 */\n    let p = clone_string ( port)                       /* line 86 */;\n    let  m =  new Message ();                          /* line 87 */;\n    m.port =  p;                                       /* line 88 */\n    m.datum =  datum.clone ();                         /* line 89 */\n    return  m;                                         /* line 90 *//* line 91 *//* line 92 */\n}\n\n/*  Clones a message. Primarily used internally for “fanning out“ a message to multiple destinations. *//* line 93 */\nfunction message_clone (msg) {                         /* line 94 */\n    let  m =  new Message ();                          /* line 95 */;\n    m.port = clone_port ( msg.port)                    /* line 96 */;\n    m.datum =  msg.datum.clone ();                     /* line 97 */\n    return  m;                                         /* line 98 *//* line 99 *//* line 100 */\n}\n\n/*  Frees a message. */                                /* line 101 */\nfunction destroy_message (msg) {                       /* line 102 */\n    /*  during debug, dont destroy any message, since we want to trace messages, thus, we need to persist ancestor messages *//* line 103 *//* line 104 *//* line 105 *//* line 106 */\n}\n\nfunction destroy_datum (msg) {                         /* line 107 *//* line 108 *//* line 109 *//* line 110 */\n}\n\nfunction destroy_port (msg) {                          /* line 111 *//* line 112 *//* line 113 *//* line 114 */\n}\n\n/*  */                                                 /* line 115 */\nfunction format_message (m) {                          /* line 116 */\n    if ( m ==  null) {                                 /* line 117 */\n      return  `${ \"‹\"}${ `${ m.port}${ `${ \"›:‹\"}${ `${ \"ϕ\"}${ \"›,\"}` }` }` }` /* line 118 */;}\n    else {                                             /* line 119 */\n      return  `${ \"‹\"}${ `${ m.port}${ `${ \"›:‹\"}${ `${ m.datum.v}${ \"›,\"}` }` }` }` /* line 120 */;/* line 121 */}/* line 122 *//* line 123 */\n}\n\nconst  enumDown =  0                                   /* line 124 */;\nconst  enumAcross =  1                                 /* line 125 */;\nconst  enumUp =  2                                     /* line 126 */;\nconst  enumThrough =  3                                /* line 127 */;/* line 128 */\nfunction create_down_connector (container,proto_conn,connectors,children_by_id) {/* line 129 */\n    /*  JSON: {;dir': 0, 'source': {'name': '', 'id': 0}, 'source_port': '', 'target': {'name': 'Echo', 'id': 12}, 'target_port': ''}, *//* line 130 */\n    let  connector =  new Connector ();                /* line 131 */;\n    connector.direction =  \"down\";                     /* line 132 */\n    connector.sender = mkSender ( container.name, container, proto_conn [ \"source_port\"])/* line 133 */;\n    let target_proto =  proto_conn [ \"target\"];        /* line 134 */\n    let id_proto =  target_proto [ \"id\"];              /* line 135 */\n    let target_component =  children_by_id [id_proto]; /* line 136 */\n    if (( target_component ==  null)) {                /* line 137 */\n      load_error ( `${ \"internal error: .Down connection target internal error \"}${( proto_conn [ \"target\"]) [ \"name\"]}` )/* line 138 */}\n    else {                                             /* line 139 */\n      connector.receiver = mkReceiver ( target_component.name, target_component, proto_conn [ \"target_port\"], target_component.inq)/* line 140 */;/* line 141 */}\n    return  connector;                                 /* line 142 *//* line 143 *//* line 144 */\n}\n\nfunction create_across_connector (container,proto_conn,connectors,children_by_id) {/* line 145 */\n    let  connector =  new Connector ();                /* line 146 */;\n    connector.direction =  \"across\";                   /* line 147 */\n    let source_component =  children_by_id [(( proto_conn [ \"source\"]) [ \"id\"])];/* line 148 */\n    let target_component =  children_by_id [(( proto_conn [ \"target\"]) [ \"id\"])];/* line 149 */\n    if ( source_component ==  null) {                  /* line 150 */\n      load_error ( `${ \"internal error: .Across connection source not ok \"}${( proto_conn [ \"source\"]) [ \"name\"]}` )/* line 151 */}\n    else {                                             /* line 152 */\n      connector.sender = mkSender ( source_component.name, source_component, proto_conn [ \"source_port\"])/* line 153 */;\n      if ( target_component ==  null) {                /* line 154 */\n        load_error ( `${ \"internal error: .Across connection target not ok \"}${( proto_conn [ \"target\"]) [ \"name\"]}` )/* line 155 */}\n      else {                                           /* line 156 */\n        connector.receiver = mkReceiver ( target_component.name, target_component, proto_conn [ \"target_port\"], target_component.inq)/* line 157 */;/* line 158 */}/* line 159 */}\n    return  connector;                                 /* line 160 *//* line 161 *//* line 162 */\n}\n\nfunction create_up_connector (container,proto_conn,connectors,children_by_id) {/* line 163 */\n    let  connector =  new Connector ();                /* line 164 */;\n    connector.direction =  \"up\";                       /* line 165 */\n    let source_component =  children_by_id [(( proto_conn [ \"source\"]) [ \"id\"])];/* line 166 */\n    if ( source_component ==  null) {                  /* line 167 */\n      load_error ( `${ \"internal error: .Up connection source not ok \"}${( proto_conn [ \"source\"]) [ \"name\"]}` )/* line 168 */}\n    else {                                             /* line 169 */\n      connector.sender = mkSender ( source_component.name, source_component, proto_conn [ \"source_port\"])/* line 170 */;\n      connector.receiver = mkReceiver ( container.name, container, proto_conn [ \"target_port\"], container.outq)/* line 171 */;/* line 172 */}\n    return  connector;                                 /* line 173 *//* line 174 *//* line 175 */\n}\n\nfunction create_through_connector (container,proto_conn,connectors,children_by_id) {/* line 176 */\n    let  connector =  new Connector ();                /* line 177 */;\n    connector.direction =  \"through\";                  /* line 178 */\n    connector.sender = mkSender ( container.name, container, proto_conn [ \"source_port\"])/* line 179 */;\n    connector.receiver = mkReceiver ( container.name, container, proto_conn [ \"target_port\"], container.outq)/* line 180 */;\n    return  connector;                                 /* line 181 *//* line 182 *//* line 183 */\n}\n                                                       /* line 184 */\nfunction container_instantiator (reg,owner,container_name,desc) {/* line 185 *//* line 186 */\n    let container = make_container ( container_name, owner)/* line 187 */;\n    let children = [];                                 /* line 188 */\n    let children_by_id = {};\n    /*  not strictly necessary, but, we can remove 1 runtime lookup by “compiling it out“ here *//* line 189 */\n    /*  collect children */                            /* line 190 */\n    for (let child_desc of  desc [ \"children\"]) {      /* line 191 */\n      let child_instance = get_component_instance ( reg, child_desc [ \"name\"], container)/* line 192 */;\n      children.push ( child_instance)                  /* line 193 */\n      let id =  child_desc [ \"id\"];                    /* line 194 */\n      children_by_id [id] =  child_instance;           /* line 195 *//* line 196 *//* line 197 */}\n    container.children =  children;                    /* line 198 *//* line 199 */\n    let connectors = [];                               /* line 200 */\n    for (let proto_conn of  desc [ \"connections\"]) {   /* line 201 */\n      let  connector =  new Connector ();              /* line 202 */;\n      if ( proto_conn [ \"dir\"] ==  enumDown) {         /* line 203 */\n        connectors.push (create_down_connector ( container, proto_conn, connectors, children_by_id)) /* line 204 */}\n      else if ( proto_conn [ \"dir\"] ==  enumAcross) {  /* line 205 */\n        connectors.push (create_across_connector ( container, proto_conn, connectors, children_by_id)) /* line 206 */}\n      else if ( proto_conn [ \"dir\"] ==  enumUp) {      /* line 207 */\n        connectors.push (create_up_connector ( container, proto_conn, connectors, children_by_id)) /* line 208 */}\n      else if ( proto_conn [ \"dir\"] ==  enumThrough) { /* line 209 */\n        connectors.push (create_through_connector ( container, proto_conn, connectors, children_by_id)) /* line 210 *//* line 211 */}/* line 212 */}\n    container.connections =  connectors;               /* line 213 */\n    return  container;                                 /* line 214 *//* line 215 *//* line 216 */\n}\n\n/*  The default handler for container components. */   /* line 217 */\nfunction container_handler (container,message) {       /* line 218 */\n    route ( container, container, message)\n    /*  references to 'self' are replaced by the container during instantiation *//* line 219 */\n    while (any_child_ready ( container)) {             /* line 220 */\n      step_children ( container, message)              /* line 221 */}/* line 222 *//* line 223 */\n}\n\n/*  Frees the given container and associated data. */  /* line 224 */\nfunction destroy_container (eh) {                      /* line 225 *//* line 226 *//* line 227 *//* line 228 */\n}\n\n/*  Routing connection for a container component. The `direction` field has *//* line 229 */\n/*  no affect on the default message routing system _ it is there for debugging *//* line 230 */\n/*  purposes, or for reading by other tools. */        /* line 231 *//* line 232 */\nclass Connector {\n  constructor () {                                     /* line 233 */\n\n    this.direction =  null;/*  down, across, up, through *//* line 234 */\n    this.sender =  null;                               /* line 235 */\n    this.receiver =  null;                             /* line 236 *//* line 237 */\n  }\n}\n                                                       /* line 238 */\n/*  `Sender` is used to “pattern match“ which `Receiver` a message should go to, *//* line 239 */\n/*  based on component ID (pointer) and port name. */  /* line 240 *//* line 241 */\nclass Sender {\n  constructor () {                                     /* line 242 */\n\n    this.name =  null;                                 /* line 243 */\n    this.component =  null;                            /* line 244 */\n    this.port =  null;                                 /* line 245 *//* line 246 */\n  }\n}\n                                                       /* line 247 *//* line 248 *//* line 249 */\n/*  `Receiver` is a handle to a destination queue, and a `port` name to assign *//* line 250 */\n/*  to incoming messages to this queue. */             /* line 251 *//* line 252 */\nclass Receiver {\n  constructor () {                                     /* line 253 */\n\n    this.name =  null;                                 /* line 254 */\n    this.queue =  null;                                /* line 255 */\n    this.port =  null;                                 /* line 256 */\n    this.component =  null;                            /* line 257 *//* line 258 */\n  }\n}\n                                                       /* line 259 */\nfunction mkSender (name,component,port) {              /* line 260 */\n    let  s =  new Sender ();                           /* line 261 */;\n    s.name =  name;                                    /* line 262 */\n    s.component =  component;                          /* line 263 */\n    s.port =  port;                                    /* line 264 */\n    return  s;                                         /* line 265 *//* line 266 *//* line 267 */\n}\n\nfunction mkReceiver (name,component,port,q) {          /* line 268 */\n    let  r =  new Receiver ();                         /* line 269 */;\n    r.name =  name;                                    /* line 270 */\n    r.component =  component;                          /* line 271 */\n    r.port =  port;                                    /* line 272 */\n    /*  We need a way to determine which queue to target. \"Down\" and \"Across\" go to inq, \"Up\" and \"Through\" go to outq. *//* line 273 */\n    r.queue =  q;                                      /* line 274 */\n    return  r;                                         /* line 275 *//* line 276 *//* line 277 */\n}\n\n/*  Checks if two senders match, by pointer equality and port name matching. *//* line 278 */\nfunction sender_eq (s1,s2) {                           /* line 279 */\n    let same_components = ( s1.component ==  s2.component);/* line 280 */\n    let same_ports = ( s1.port ==  s2.port);           /* line 281 */\n    return (( same_components) && ( same_ports));      /* line 282 *//* line 283 *//* line 284 */\n}\n\n/*  Delivers the given message to the receiver of this connector. *//* line 285 *//* line 286 */\nfunction deposit (parent,conn,message) {               /* line 287 */\n    let new_message = make_message ( conn.receiver.port, message.datum)/* line 288 */;\n    push_message ( parent, conn.receiver.component, conn.receiver.queue, new_message)/* line 289 *//* line 290 *//* line 291 */\n}\n\nfunction force_tick (parent,eh) {                      /* line 292 */\n    let tick_msg = make_message ( \".\",new_datum_bang ())/* line 293 */;\n    push_message ( parent, eh, eh.inq, tick_msg)       /* line 294 */\n    return  tick_msg;                                  /* line 295 *//* line 296 *//* line 297 */\n}\n\nfunction push_message (parent,receiver,inq,m) {        /* line 298 */\n    inq.push ( m)                                      /* line 299 */\n    parent.visit_ordering.push ( receiver)             /* line 300 *//* line 301 *//* line 302 */\n}\n\nfunction is_self (child,container) {                   /* line 303 */\n    /*  in an earlier version “self“ was denoted as ϕ *//* line 304 */\n    return  child ==  container;                       /* line 305 *//* line 306 *//* line 307 */\n}\n\nfunction step_child (child,msg) {                      /* line 308 */\n    let before_state =  child.state;                   /* line 309 */\n    child.handler ( child, msg)                        /* line 310 */\n    let after_state =  child.state;                    /* line 311 */\n    return [(( before_state ==  \"idle\") && ( after_state!= \"idle\")),(( before_state!= \"idle\") && ( after_state!= \"idle\")),(( before_state!= \"idle\") && ( after_state ==  \"idle\"))];/* line 314 *//* line 315 *//* line 316 */\n}\n\nfunction step_children (container,causingMessage) {    /* line 317 */\n    container.state =  \"idle\";                         /* line 318 */\n    for (let child of   container.visit_ordering) {    /* line 319 */\n      /*  child = container represents self, skip it *//* line 320 */\n      if (((! (is_self ( child, container))))) {       /* line 321 */\n        if (((! ((0=== child.inq.length))))) {         /* line 322 */\n          let msg =  child.inq.shift ()                /* line 323 */;\n          let  began_long_run =  null;                 /* line 324 */\n          let  continued_long_run =  null;             /* line 325 */\n          let  ended_long_run =  null;                 /* line 326 */\n          [ began_long_run, continued_long_run, ended_long_run] = step_child ( child, msg)/* line 327 */;\n          if ( began_long_run) {                       /* line 328 *//* line 329 */}\n          else if ( continued_long_run) {              /* line 330 *//* line 331 */}\n          else if ( ended_long_run) {                  /* line 332 *//* line 333 *//* line 334 */}\n          destroy_message ( msg)                       /* line 335 */}\n        else {                                         /* line 336 */\n          if ( child.state!= \"idle\") {                 /* line 337 */\n            let msg = force_tick ( container, child)   /* line 338 */;\n            child.handler ( child, msg)                /* line 339 */\n            destroy_message ( msg)                     /* line 340 *//* line 341 */}/* line 342 */}/* line 343 */\n        if ( child.state ==  \"active\") {               /* line 344 */\n          /*  if child remains active, then the container must remain active and must propagate “ticks“ to child *//* line 345 */\n          container.state =  \"active\";                 /* line 346 *//* line 347 */}/* line 348 */\n        while (((! ((0=== child.outq.length))))) {     /* line 349 */\n          let msg =  child.outq.shift ()               /* line 350 */;\n          route ( container, child, msg)               /* line 351 */\n          destroy_message ( msg)                       /* line 352 *//* line 353 */}/* line 354 */}/* line 355 */}/* line 356 *//* line 357 */\n}\n\nfunction attempt_tick (parent,eh) {                    /* line 358 */\n    if ( eh.state!= \"idle\") {                          /* line 359 */\n      force_tick ( parent, eh)                         /* line 360 *//* line 361 */}/* line 362 *//* line 363 */\n}\n\nfunction is_tick (msg) {                               /* line 364 */\n    return  \".\" ==  msg.port\n    /*  assume that any message that is sent to port \".\" is a tick  *//* line 365 */;/* line 366 *//* line 367 */\n}\n\n/*  Routes a single message to all matching destinations, according to *//* line 368 */\n/*  the container's connection network. */             /* line 369 *//* line 370 */\nfunction route (container,from_component,message) {    /* line 371 */\n    let  was_sent =  false;\n    /*  for checking that output went somewhere (at least during bootstrap) *//* line 372 */\n    let  fromname =  \"\";                               /* line 373 */\n    if (is_tick ( message)) {                          /* line 374 */\n      for (let child of  container.children) {         /* line 375 */\n        attempt_tick ( container, child)               /* line 376 */}\n      was_sent =  true;                                /* line 377 */}\n    else {                                             /* line 378 */\n      if (((! (is_self ( from_component, container))))) {/* line 379 */\n        fromname =  from_component.name;               /* line 380 *//* line 381 */}\n      let from_sender = mkSender ( fromname, from_component, message.port)/* line 382 */;/* line 383 */\n      for (let connector of  container.connections) {  /* line 384 */\n        if (sender_eq ( from_sender, connector.sender)) {/* line 385 */\n          deposit ( container, connector, message)     /* line 386 */\n          was_sent =  true;                            /* line 387 *//* line 388 */}/* line 389 */}/* line 390 */}\n    if ((! ( was_sent))) {                             /* line 391 */\n      console.error ( \"\\n\\n*** Error: ***\");           /* line 392 */\n      console.error ( \"***\");                          /* line 393 */\n      console.error ( `${ container.name}${ `${ \": message '\"}${ `${ message.port}${ `${ \"' from \"}${ `${ fromname}${ \" dropped on floor...\"}` }` }` }` }` );/* line 394 */\n      console.error ( \"***\");                          /* line 395 */\n      process.exit (1)                                 /* line 396 *//* line 397 */}/* line 398 *//* line 399 */\n}\n\nfunction any_child_ready (container) {                 /* line 400 */\n    for (let child of  container.children) {           /* line 401 */\n      if (child_is_ready ( child)) {                   /* line 402 */\n        return  true;                                  /* line 403 *//* line 404 */}/* line 405 */}\n    return  false;                                     /* line 406 *//* line 407 *//* line 408 */\n}\n\nfunction child_is_ready (eh) {                         /* line 409 */\n    return ((((((((! ((0=== eh.outq.length))))) || (((! ((0=== eh.inq.length))))))) || (( eh.state!= \"idle\")))) || ((any_child_ready ( eh))));/* line 410 *//* line 411 *//* line 412 */\n}\n\nfunction append_routing_descriptor (container,desc) {  /* line 413 */\n    container.routings.push ( desc)                    /* line 414 *//* line 415 *//* line 416 */\n}\n\nfunction container_injector (container,message) {      /* line 417 */\n    container_handler ( container, message)            /* line 418 *//* line 419 *//* line 420 */\n}\n                                                       /* line 421 *//* line 422 *//* line 423 */\nclass Component_Registry {\n  constructor () {                                     /* line 424 */\n\n    this.templates = {};                               /* line 425 *//* line 426 */\n  }\n}\n                                                       /* line 427 */\nclass Template {\n  constructor () {                                     /* line 428 */\n\n    this.name =  null;                                 /* line 429 */\n    this.template_data =  null;                        /* line 430 */\n    this.instantiator =  null;                         /* line 431 *//* line 432 */\n  }\n}\n                                                       /* line 433 */\nfunction mkTemplate (name,template_data,instantiator) {/* line 434 */\n    let  templ =  new Template ();                     /* line 435 */;\n    templ.name =  name;                                /* line 436 */\n    templ.template_data =  template_data;              /* line 437 */\n    templ.instantiator =  instantiator;                /* line 438 */\n    return  templ;                                     /* line 439 *//* line 440 *//* line 441 */\n}\n\nfunction read_and_convert_json_file (pathname,filename) {/* line 442 */\n\n    console.log (filename);\n    let jstr = undefined;\n    if (filename == \"0\") {\n    jstr = fs.readFileSync (0);\n    } else if (pathname) {\n    jstr = fs.readFileSync (`${pathname}/${filename}`);\n    } else {\n    jstr = fs.readFileSync (`${filename}`);\n    }\n    if (jstr) {\n    return JSON.parse (jstr);\n    } else {\n    return undefined;\n    }\n                                                       /* line 443 *//* line 444 *//* line 445 */\n}\n\nfunction json2internal (pathname,container_xml) {      /* line 446 */\n    let fname =   container_xml                        /* line 447 */;\n    let routings = read_and_convert_json_file ( pathname, fname)/* line 448 */;\n    return  routings;                                  /* line 449 *//* line 450 *//* line 451 */\n}\n\nfunction delete_decls (d) {                            /* line 452 *//* line 453 *//* line 454 *//* line 455 */\n}\n\nfunction make_component_registry () {                  /* line 456 */\n    return  new Component_Registry ();                 /* line 457 */;/* line 458 *//* line 459 */\n}\n\nfunction register_component (reg,template) {\n    return abstracted_register_component ( reg, template, false);/* line 460 */\n}\n\nfunction register_component_allow_overwriting (reg,template) {\n    return abstracted_register_component ( reg, template, true);/* line 461 *//* line 462 */\n}\n\nfunction abstracted_register_component (reg,template,ok_to_overwrite) {/* line 463 */\n    let name = mangle_name ( template.name)            /* line 464 */;\n    if ((((((( reg!= null) && ( name))) in ( reg.templates))) && ((!  ok_to_overwrite)))) {/* line 465 */\n      load_error ( `${ \"Component /\"}${ `${ template.name}${ \"/ already declared\"}` }` )/* line 466 */\n      return  reg;                                     /* line 467 */}\n    else {                                             /* line 468 */\n      reg.templates [name] =  template;                /* line 469 */\n      return  reg;                                     /* line 470 *//* line 471 */}/* line 472 *//* line 473 */\n}\n\nfunction get_component_instance (reg,full_name,owner) {/* line 474 */\n    let template_name = mangle_name ( full_name)       /* line 475 */;\n    if ((( template_name) in ( reg.templates))) {      /* line 476 */\n      let template =  reg.templates [template_name];   /* line 477 */\n      if (( template ==  null)) {                      /* line 478 */\n        load_error ( `${ \"Registry Error (A): Can't find component /\"}${ `${ template_name}${ \"/\"}` }` )/* line 479 */\n        return  null;                                  /* line 480 */}\n      else {                                           /* line 481 */\n        let owner_name =  \"\";                          /* line 482 */\n        let instance_name =  template_name;            /* line 483 */\n        if ( null!= owner) {                           /* line 484 */\n          owner_name =  owner.name;                    /* line 485 */\n          instance_name =  `${ owner_name}${ `${ \".\"}${ template_name}` }` /* line 486 */;}\n        else {                                         /* line 487 */\n          instance_name =  template_name;              /* line 488 *//* line 489 */}\n        let instance =  template.instantiator ( reg, owner, instance_name, template.template_data)/* line 490 */;\n        return  instance;                              /* line 491 *//* line 492 */}}\n    else {                                             /* line 493 */\n      load_error ( `${ \"Registry Error (B): Can't find component /\"}${ `${ template_name}${ \"/\"}` }` )/* line 494 */\n      return  null;                                    /* line 495 *//* line 496 */}/* line 497 *//* line 498 */\n}\n\nfunction dump_registry (reg) {                         /* line 499 */\n    nl ()                                              /* line 500 */\n    console.log ( \"*** PALETTE ***\");                  /* line 501 */\n    for (let c of  reg.templates) {                    /* line 502 */\n      print ( c.name)                                  /* line 503 */}\n    console.log ( \"***************\");                  /* line 504 */\n    nl ()                                              /* line 505 *//* line 506 *//* line 507 */\n}\n\nfunction print_stats (reg) {                           /* line 508 */\n    console.log ( `${ \"registry statistics: \"}${ reg.stats}` );/* line 509 *//* line 510 *//* line 511 */\n}\n\nfunction mangle_name (s) {                             /* line 512 */\n    /*  trim name to remove code from Container component names _ deferred until later (or never) *//* line 513 */\n    return  s;                                         /* line 514 *//* line 515 *//* line 516 */\n}\n                                                       /* line 517 */\n/*  Data for an asyncronous component _ effectively, a function with input *//* line 518 */\n/*  and output queues of messages. */                  /* line 519 */\n/*  */                                                 /* line 520 */\n/*  Components can either be a user_supplied function (“lea“), or a “container“ *//* line 521 */\n/*  that routes messages to child components according to a list of connections *//* line 522 */\n/*  that serve as a message routing table. */          /* line 523 */\n/*  */                                                 /* line 524 */\n/*  Child components themselves can be leaves or other containers. *//* line 525 */\n/*  */                                                 /* line 526 */\n/*  `handler` invokes the code that is attached to this component. *//* line 527 */\n/*  */                                                 /* line 528 */\n/*  `instance_data` is a pointer to instance data that the `leaf_handler` *//* line 529 */\n/*  function may want whenever it is invoked again. */ /* line 530 */\n/*  */                                                 /* line 531 *//* line 532 */\n/*  Eh_States :: enum { idle, active } */              /* line 533 */\nclass Eh {\n  constructor () {                                     /* line 534 */\n\n    this.name =  \"\";                                   /* line 535 */\n    this.inq =  []                                     /* line 536 */;\n    this.outq =  []                                    /* line 537 */;\n    this.owner =  null;                                /* line 538 */\n    this.children = [];                                /* line 539 */\n    this.visit_ordering =  []                          /* line 540 */;\n    this.connections = [];                             /* line 541 */\n    this.routings =  []                                /* line 542 */;\n    this.handler =  null;                              /* line 543 */\n    this.finject =  null;                              /* line 544 */\n    this.instance_data =  null;                        /* line 545 */\n    this.state =  \"idle\";                              /* line 546 *//*  bootstrap debugging *//* line 547 */\n    this.kind =  null;/*  enum { container, leaf, } */ /* line 548 *//* line 549 */\n  }\n}\n                                                       /* line 550 */\n/*  Creates a component that acts as a container. It is the same as a `Eh` instance *//* line 551 */\n/*  whose handler function is `container_handler`. */  /* line 552 */\nfunction make_container (name,owner) {                 /* line 553 */\n    let  eh =  new Eh ();                              /* line 554 */;\n    eh.name =  name;                                   /* line 555 */\n    eh.owner =  owner;                                 /* line 556 */\n    eh.handler =  container_handler;                   /* line 557 */\n    eh.finject =  container_injector;                  /* line 558 */\n    eh.state =  \"idle\";                                /* line 559 */\n    eh.kind =  \"container\";                            /* line 560 */\n    return  eh;                                        /* line 561 *//* line 562 *//* line 563 */\n}\n\n/*  Creates a new leaf component out of a handler function, and a data parameter *//* line 564 */\n/*  that will be passed back to your handler when called. *//* line 565 *//* line 566 */\nfunction make_leaf (name,owner,instance_data,handler) {/* line 567 */\n    let  eh =  new Eh ();                              /* line 568 */;\n    eh.name =  `${ owner.name}${ `${ \".\"}${ name}` }`  /* line 569 */;\n    eh.owner =  owner;                                 /* line 570 */\n    eh.handler =  handler;                             /* line 571 */\n    eh.instance_data =  instance_data;                 /* line 572 */\n    eh.state =  \"idle\";                                /* line 573 */\n    eh.kind =  \"leaf\";                                 /* line 574 */\n    return  eh;                                        /* line 575 *//* line 576 *//* line 577 */\n}\n\n/*  Sends a message on the given `port` with `data`, placing it on the output *//* line 578 */\n/*  of the given component. */                         /* line 579 *//* line 580 */\nfunction send (eh,port,datum,causingMessage) {         /* line 581 */\n    let msg = make_message ( port, datum)              /* line 582 */;\n    put_output ( eh, msg)                              /* line 583 *//* line 584 *//* line 585 */\n}\n\nfunction send_string (eh,port,s,causingMessage) {      /* line 586 */\n    let datum = new_datum_string ( s)                  /* line 587 */;\n    let msg = make_message ( port, datum)              /* line 588 */;\n    put_output ( eh, msg)                              /* line 589 *//* line 590 *//* line 591 */\n}\n\nfunction forward (eh,port,msg) {                       /* line 592 */\n    let fwdmsg = make_message ( port, msg.datum)       /* line 593 */;\n    put_output ( eh, fwdmsg)                           /* line 594 *//* line 595 *//* line 596 */\n}\n\nfunction inject (eh,msg) {                             /* line 597 */\n    eh.finject ( eh, msg)                              /* line 598 *//* line 599 *//* line 600 */\n}\n\n/*  Returns a list of all output messages on a container. *//* line 601 */\n/*  For testing / debugging purposes. */               /* line 602 *//* line 603 */\nfunction output_list (eh) {                            /* line 604 */\n    return  eh.outq;                                   /* line 605 *//* line 606 *//* line 607 */\n}\n\n/*  Utility for printing an array of messages. */      /* line 608 */\nfunction print_output_list (eh) {                      /* line 609 */\n    console.log ( \"{\");                                /* line 610 */\n    for (let m of   eh.outq) {                         /* line 611 */\n      console.log (format_message ( m));               /* line 612 *//* line 613 */}\n    console.log ( \"}\");                                /* line 614 *//* line 615 *//* line 616 */\n}\n\nfunction spaces (n) {                                  /* line 617 */\n    let  s =  \"\";                                      /* line 618 */\n    for (let i of range( n)) {                         /* line 619 */\n      s =  s+ \" \";                                     /* line 620 */}\n    return  s;                                         /* line 621 *//* line 622 *//* line 623 */\n}\n\nfunction set_active (eh) {                             /* line 624 */\n    eh.state =  \"active\";                              /* line 625 *//* line 626 *//* line 627 */\n}\n\nfunction set_idle (eh) {                               /* line 628 */\n    eh.state =  \"idle\";                                /* line 629 *//* line 630 *//* line 631 */\n}\n\n/*  Utility for printing a specific output message. */ /* line 632 *//* line 633 */\nfunction fetch_first_output (eh,port) {                /* line 634 */\n    for (let msg of   eh.outq) {                       /* line 635 */\n      if (( msg.port ==  port)) {                      /* line 636 */\n        return  msg.datum;}                            /* line 637 */}\n    return  null;                                      /* line 638 *//* line 639 *//* line 640 */\n}\n\nfunction print_specific_output (eh,port) {             /* line 641 */\n    /*  port ∷ “” */                                   /* line 642 */\n    let  datum = fetch_first_output ( eh, port)        /* line 643 */;\n    console.log ( datum.v);                            /* line 644 *//* line 645 */\n}\n\nfunction print_specific_output_to_stderr (eh,port) {   /* line 646 */\n    /*  port ∷ “” */                                   /* line 647 */\n    let  datum = fetch_first_output ( eh, port)        /* line 648 */;\n    /*  I don't remember why I found it useful to print to stderr during bootstrapping, so I've left it in... *//* line 649 */\n    console.error ( datum.v);                          /* line 650 *//* line 651 *//* line 652 */\n}\n\nfunction put_output (eh,msg) {                         /* line 653 */\n    eh.outq.push ( msg)                                /* line 654 *//* line 655 *//* line 656 */\n}\n\nlet  root_project =  \"\";                               /* line 657 */\nlet  root_0D =  \"\";                                    /* line 658 *//* line 659 */\nfunction set_environment (rproject,r0D) {              /* line 660 *//* line 661 *//* line 662 */\n    root_project =  rproject;                          /* line 663 */\n    root_0D =  r0D;                                    /* line 664 *//* line 665 *//* line 666 */\n}\n                                                       /* line 667 */\nfunction string_make_persistent (s) {                  /* line 668 */\n    /*  this is here for non_GC languages like Odin, it is a no_op for GC languages like Python *//* line 669 */\n    return  s;                                         /* line 670 *//* line 671 *//* line 672 */\n}\n\nfunction string_clone (s) {                            /* line 673 */\n    return  s;                                         /* line 674 *//* line 675 *//* line 676 */\n}\n\n/*  usage: app ${_00_} ${_0D_} arg main diagram_filename1 diagram_filename2 ... *//* line 677 */\n/*  where ${_00_} is the root directory for the project *//* line 678 */\n/*  where ${_0D_} is the root directory for 0D (e.g. 0D/odin or 0D/python) *//* line 679 *//* line 680 */\nfunction initialize_component_palette (root_project,root_0D,diagram_source_files) {/* line 681 */\n    let  reg = make_component_registry ();             /* line 682 */\n    for (let diagram_source of  diagram_source_files) {/* line 683 */\n      let all_containers_within_single_file = json2internal ( root_project, diagram_source)/* line 684 */;\n      reg = generate_shell_components ( reg, all_containers_within_single_file)/* line 685 */;\n      for (let container of  all_containers_within_single_file) {/* line 686 */\n        register_component ( reg,mkTemplate ( container [ \"name\"], container, container_instantiator))/* line 687 *//* line 688 */}/* line 689 */}\n    initialize_stock_components ( reg)                 /* line 690 */\n    return  reg;                                       /* line 691 *//* line 692 *//* line 693 */\n}\n\nfunction print_error_maybe (main_container) {          /* line 694 */\n    let error_port =  \"✗\";                             /* line 695 */\n    let err = fetch_first_output ( main_container, error_port)/* line 696 */;\n    if (((( err!= null)) && (( 0 < (trimws ( err.v).length))))) {/* line 697 */\n      console.log ( \"___ !!! ERRORS !!! ___\");         /* line 698 */\n      print_specific_output ( main_container, error_port)/* line 699 *//* line 700 */}/* line 701 *//* line 702 */\n}\n\n/*  debugging helpers */                               /* line 703 *//* line 704 */\nfunction nl () {                                       /* line 705 */\n    console.log ( \"\");                                 /* line 706 *//* line 707 *//* line 708 */\n}\n\nfunction dump_outputs (main_container) {               /* line 709 */\n    nl ()                                              /* line 710 */\n    console.log ( \"___ Outputs ___\");                  /* line 711 */\n    print_output_list ( main_container)                /* line 712 *//* line 713 *//* line 714 */\n}\n\nfunction trimws (s) {                                  /* line 715 */\n    /*  remove whitespace from front and back of string *//* line 716 */\n    return  s.strip ();                                /* line 717 *//* line 718 *//* line 719 */\n}\n\nfunction clone_string (s) {                            /* line 720 */\n    return  s                                          /* line 721 *//* line 722 */;/* line 723 */\n}\n\nlet  load_errors =  false;                             /* line 724 */\nlet  runtime_errors =  false;                          /* line 725 *//* line 726 */\nfunction load_error (s) {                              /* line 727 *//* line 728 */\n    console.log ( s);                                  /* line 729 */\n    console.log ();                                    /* line 730 */\n    load_errors =  true;                               /* line 731 *//* line 732 *//* line 733 */\n}\n\nfunction runtime_error (s) {                           /* line 734 *//* line 735 */\n    console.log ( s);                                  /* line 736 */\n    runtime_errors =  true;                            /* line 737 *//* line 738 *//* line 739 */\n}\n                                                       /* line 740 */\nfunction argv () {                                     /* line 741 */\n    return  command_line_argv                          /* line 742 */;/* line 743 *//* line 744 */\n}\n\nfunction initialize () {                               /* line 745 */\n    let root_of_project =  command_line_argv[ 1]       /* line 746 */;\n    let root_of_0D =  command_line_argv[ 2]            /* line 747 */;\n    let arg =  command_line_argv[ 3]                   /* line 748 */;\n    let main_container_name =  command_line_argv[ 4]   /* line 749 */;\n    let diagram_names =  command_line_argv.splice ( 5) /* line 750 */;\n    let palette = initialize_component_palette ( root_of_project, root_of_0D, diagram_names)/* line 751 */;\n    return [ palette,[ root_of_project, root_of_0D, main_container_name, diagram_names, arg]];/* line 752 *//* line 753 *//* line 754 */\n}\n\nfunction start (palette,env) {\n    start_helper ( palette, env, false)                /* line 755 */\n}\n\nfunction start_show_all (palette,env) {\n    start_helper ( palette, env, true)                 /* line 756 */\n}\n\nfunction start_helper (palette,env,show_all_outputs) { /* line 757 */\n    let root_of_project =  env [ 0];                   /* line 758 */\n    let root_of_0D =  env [ 1];                        /* line 759 */\n    let main_container_name =  env [ 2];               /* line 760 */\n    let diagram_names =  env [ 3];                     /* line 761 */\n    let arg =  env [ 4];                               /* line 762 */\n    set_environment ( root_of_project, root_of_0D)     /* line 763 */\n    /*  get entrypoint container */                    /* line 764 */\n    let  main_container = get_component_instance ( palette, main_container_name, null)/* line 765 */;\n    if ( null ==  main_container) {                    /* line 766 */\n      load_error ( `${ \"Couldn't find container with page name /\"}${ `${ main_container_name}${ `${ \"/ in files \"}${ `${`${ diagram_names}`}${ \" (check tab names, or disable compression?)\"}` }` }` }` )/* line 770 *//* line 771 */}\n    if ((!  load_errors)) {                            /* line 772 */\n      let  marg = new_datum_string ( arg)              /* line 773 */;\n      let  msg = make_message ( \"\", marg)              /* line 774 */;\n      inject ( main_container, msg)                    /* line 775 */\n      if ( show_all_outputs) {                         /* line 776 */\n        dump_outputs ( main_container)                 /* line 777 */}\n      else {                                           /* line 778 */\n        print_error_maybe ( main_container)            /* line 779 */\n        let outp = fetch_first_output ( main_container, \"\")/* line 780 */;\n        if ( null ==  outp) {                          /* line 781 */\n          console.log ( \"«««no outputs»»»)\");          /* line 782 */}\n        else {                                         /* line 783 */\n          print_specific_output ( main_container, \"\")  /* line 784 *//* line 785 */}/* line 786 */}\n      if ( show_all_outputs) {                         /* line 787 */\n        console.log ( \"--- done ---\");                 /* line 788 *//* line 789 */}/* line 790 */}/* line 791 *//* line 792 */\n}\n                                                       /* line 793 */\n/*  utility functions  */                              /* line 794 */\nfunction send_int (eh,port,i,causing_message) {        /* line 795 */\n    let datum = new_datum_string (`${ i}`)             /* line 796 */;\n    send ( eh, port, datum, causing_message)           /* line 797 *//* line 798 *//* line 799 */\n}\n\nfunction send_bang (eh,port,causing_message) {         /* line 800 */\n    let datum = new_datum_bang ();                     /* line 801 */\n    send ( eh, port, datum, causing_message)           /* line 802 *//* line 803 */\n}",\n
