import os
import json
import sys


defobj Component_Registry () {
        • templates ⇐ {}
}

defobj Template (name, template_data, instantiator) {
        • name ⇐ name
        • template_data ⇐ template_data
        • instantiator ⇐ instantiator
}

defn read_and_convert_json_file (filename) {
    # read_and_convert_json_file (filename)
}

defn json2internal (container_xml) {
    fname ≡ os.path.basename (container_xml)
    routings ≡ read_and_convert_json_file (fname)
    return routings
}

defn delete_decls (d) {
    pass
}

defn make_component_registry () {
    return Component_Registry ()
}

defn register_component (reg, template, ok_to_overwrite ∷ ⊥) {
    name ≡ mangle_name (template.name)
    if name in reg.templates and not ok_to_overwrite {
        load_error (strcons (“Component ”, strcons (template.name, “ already declared”)))}
    reg.templates[name] ⇐ template
    return reg
}

defn register_multiple_components (reg, templates) {
    for template in templates {
        register_component (reg, template)}
}

defn get_component_instance (reg, full_name, owner) {
    template_name ≡ mangle_name (full_name)
    if template_name in reg.templates {
        template ≡ reg.templates[template_name]
        if (template = ϕ) {
            load_error (strcons (“Registry Error: Can't find component ”, strcons (template_name, “ (does it need to be declared in components_to_include_in_project?”)))
            return ϕ}
        else {
            owner_name ≡ “”
            instance_name ≡ template_name
            if ϕ != owner {
                owner_name ≡ owner.name
                instance_name ≡ strcons (owner_name, strcons (“.”, template_name))}
            else{
                instance_name ≡ template_name}
            instance ≡ template.instantiator (reg, owner, instance_name, template.template_data)
            instance.depth ⇐ calculate_depth (instance)
            return instance }}
    else {
            load_error (strcons (“Registry Error: Can't find component ”, strcons (template_name, “ (does it need to be declared in components_to_include_in_project?”)))
            return ϕ}
}
defn calculate_depth (eh) {
    if eh.owner = ϕ {
        return 0}
    else {
        return 1 + calculate_depth (eh.owner)}
}

defn dump_registry (reg) {
    print ()
    print (“*** PALETTE ***”)
    for c in reg.templates{
        print (c.name)}
    print (“***************”)
    print ()
}

defn print_stats (reg) {
    print (strcons (“registry statistics: ”, reg.stats))
}

defn mangle_name (s) {
    ⌈ trim name to remove code from Container component names _ deferred until later (or never)⌉
    return s
}

import subprocess
defn generate_shell_components (reg, container_list) {
    ⌈ [⌉
    ⌈     {'file': 'simple0d.drawio', 'name': 'main', 'children': [{'name': 'Echo', 'id': 5}], 'connections': [...]},⌉
    ⌈     {'file': 'simple0d.drawio', 'name': '...', 'children': [], 'connections': []}⌉
    ⌈ ]⌉
    if ϕ != container_list {
        for diagram in container_list{
            ⌈ loop through every component in the diagram and look for names that start with “$“⌉
            ⌈ {'file': 'simple0d.drawio', 'name': 'main', 'children': [{'name': 'Echo', 'id': 5}], 'connections': [...]},⌉
            for child_descriptor in diagram@children{
                if first_char_is (child_descriptor@name, “$”){
                    name ≡ child_descriptor@name
                    cmd ≡ stringcdr (name).strip ()
                    generated_leaf ≡ Template (name ∷ name, instantiator ∷ shell_out_instantiate, template_data ∷ cmd)
                    register_component (reg, generated_leaf)}
                elif first_char_is (child_descriptor@name, “'”){
                    name ≡ child_descriptor@name
                    s ≡ stringcdr (name)
                    generated_leaf ≡ Template (name ∷ name, instantiator ∷ string_constant_instantiate, template_data ∷ s)
                    register_component (reg, generated_leaf, ok_to_overwrite ∷ ⊤)}}}}
}

defn first_char (s) {
    return car (s)
}

defn first_char_is (s, c) {
    return c = first_char (s)
}

⌈ this needs to be rewritten to use the low_level “shell_out“ component, this can be done solely as a diagram without using python code here⌉
⌈ I'll keep it for now, during bootstrapping, since it mimics what is done in the Odin prototype _ both need to be revamped⌉
defn run_command (eh, cmd, s) {
    ret ≡ subprocess.run (cmd, capture_output ∷ ⊤, input ∷ s, encoding ∷ “UTF_8”)
    if  not (ret.returncode = 0){
        if ret.stderr != ϕ{
            return [“”, ret.stderr]}
        else{
            return [“”, strcons (“error in shell_out ”, ret.returncode)]}}
    else{
        return [ret.stdout, ϕ]}
}

⌈ Data for an asyncronous component _ effectively, a function with input⌉
⌈ and output queues of messages.⌉
⌈⌉
⌈ Components can either be a user_supplied function (“lea“), or a “container“⌉
⌈ that routes messages to child components according to a list of connections⌉
⌈ that serve as a message routing table.⌉
⌈⌉
⌈ Child components themselves can be leaves or other containers.⌉
⌈⌉
⌈ `handler` invokes the code that is attached to this component.⌉
⌈⌉
⌈ `instance_data` is a pointer to instance data that the `leaf_handler`⌉
⌈ function may want whenever it is invoked again.⌉
⌈⌉

import queue
import sys


⌈ Eh_States :: enum { idle, active }⌉
defobj Eh () {
        • name ⇐ “”
        • inq ⇐ queue.Queue ()
        • outq ⇐ queue.Queue ()
        • owner ⇐ ϕ
        • saved_messages ⇐ queue.LifoQueue () ⌈ stack of saved message(s)⌉
        • inject ⇐ injector_NIY
        • children ⇐ []
        • visit_ordering ⇐ queue.Queue ()
        • connections ⇐ []
        • routings ⇐ queue.Queue ()
        • handler ⇐ ϕ
        • instance_data ⇐ ϕ
        • state ⇐ “idle”
        ⌈ bootstrap debugging⌉
        • kind ⇐ ϕ ⌈ enum { container, leaf, }⌉
        • trace ⇐ ⊥ ⌈ set '⊤' if logging is enabled and if this component should be traced, (⊥ means silence, no tracing for this component)⌉
        • depth ⇐ 0 ⌈ hierarchical depth of component, 0=top, 1=1st child of top, 2=1st child of 1st child of top, etc.⌉
}

⌈ Creates a component that acts as a container. It is the same as a `Eh` instance⌉
⌈ whose handler function is `container_handler`.⌉
defn make_container (name, owner) {
    eh ≡ Eh ()
    eh.name ⇐ name
    eh.owner ⇐ owner
    eh.handler ⇐ container_handler
    eh.inject ⇐ container_injector
    eh.state ⇐ “idle”
    eh.kind ⇐ “container”
    return eh
}

⌈ Creates a new leaf component out of a handler function, and a data parameter⌉
⌈ that will be passed back to your handler when called.⌉

defn make_leaf (name, owner, instance_data, handler) {
    eh ≡ Eh ()
    eh.name ⇐ strcons (owner.name, strcons (“.”, name))
    eh.owner ⇐ owner
    eh.handler ⇐ handler
    eh.instance_data ⇐ instance_data
    eh.state ⇐ “idle”
    eh.kind ⇐ “leaf”
    return eh
}

⌈ Sends a message on the given `port` with `data`, placing it on the output⌉
⌈ of the given component.⌉

defn send (eh,port,datum,causingMessage) {
    msg ≡ make_message(port, datum)
    log_send (sender ∷ eh, sender_port ∷ port, msg ∷ msg, cause_msg ∷ causingMessage)
    put_output (eh, msg)
}

defn send_string (eh, port, s, causingMessage) {
    datum ≡ new_datum_string (s)
    msg ≡ make_message(port ∷ port, datum ∷ datum)
    log_send_string (sender ∷ eh, sender_port ∷ port, msg ∷ msg, cause_msg ∷ causingMessage)
    put_output (eh, msg)
}

defn forward (eh, port, msg) {
    fwdmsg ≡ make_message(port, msg.datum)
    log_forward (sender ∷ eh, sender_port ∷ port, msg ∷ msg, cause_msg ∷ msg)
    put_output (eh, msg)
}

defn inject (eh, msg) {
    eh.inject (eh, msg)
}

⌈ Returns a list of all output messages on a container.⌉
⌈ For testing / debugging purposes.⌉

defn output_list (eh) {
    return eh.outq
}

⌈ Utility for printing an array of messages.⌉
defn print_output_list (eh) {
    for m in list (eh.outq.queue) {
        print (format_message (m))}
}

defn spaces (n) {
    deftemp s ⇐ “”
    for i in range (n){
        s ⇐ s + “ ”}
    return s
}

defn set_active (eh) {
    eh.state ⇐ “active”
}

defn set_idle (eh) {
    eh.state ⇐ “idle”
}

⌈ Utility for printing a specific output message.⌉

defn fetch_first_output (eh, port) {
    for msg in list (eh.outq.queue) {
        if (msg.port = port){
            return msg.datum}}
    return ϕ
}

defn print_specific_output (eh, port ∷ “”, stderr ∷ ⊥) {
    deftemp datum ⇐ fetch_first_output (eh, port)
    deftemp outf ⇐ ϕ
    if datum != ϕ{
        if stderr{              ⌈ I don't remember why I found it useful to print to stderr during bootstrapping, so I've left it in...⌉
            outf ⇐ sys.stderr}
        else{
            outf ⇐ sys.stdout}
        print (datum.srepr (), file ∷ outf)}
}

defn put_output (eh, msg) {
    eh.outq.put (msg)
}

defn injector_NIY (eh, msg) {
   ⌈ print (f'Injector not implemented for this component “{eh.name}“ kind ∷ {eh.kind} port ∷ “{msg.port}“')⌉
   print (strcons (“Injector not implemented for this component ”,
            strcons (eh.name,
	      strcons (“ kind ∷ ”,
	        strcons (eh.kind,
		  strcons (“,  port ∷ ”, msg.port))))))
    exit ()
}

import sys
import re
import subprocess
import shlex

defvar root_project ⇐ “”
defvar root_0D ⇐ “”

defn set_environment (rproject, r0D) {
    global root_project
    global root_0D
    root_project ⇐ rproject
    root_0D ⇐ r0D
}

defn probe_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“?”)
    return make_leaf (name ∷ name_with_id, owner ∷ owner, instance_data ∷ ϕ, handler ∷ probe_handler)
}
defn probeA_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“?A”)
    return make_leaf (name ∷ name_with_id, owner ∷ owner, instance_data ∷ ϕ, handler ∷ probe_handler)
}

defn probeB_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol(“?B”)
    return make_leaf (name ∷ name_with_id, owner ∷ owner, instance_data ∷ ϕ, handler ∷ probe_handler)
}

defn probeC_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol(“?C”)
    return make_leaf (name ∷ name_with_id, owner ∷ owner, instance_data ∷ ϕ, handler ∷ probe_handler)
}

defn probe_handler (eh, msg) {
    s ≡ msg.datum.srepr ()
    print (strcons (“... probe ”, strcons (eh.name, strcons (“: ”, s))), file ∷ sys.stderr)
}

defn trash_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“trash”)
    return make_leaf (name ∷ name_with_id, owner ∷ owner, instance_data ∷ ϕ, handler ∷ trash_handler)
}

defn trash_handler (eh, msg) {
    ⌈ to appease dumped_on_floor checker⌉
    pass
}
defobj TwoMessages (first, second) {
        • first ⇐ first
        • second ⇐ second
}

⌈ Deracer_States :: enum { idle, waitingForFirst, waitingForSecond }⌉
defobj Deracer_Instance_Data (state, buffer) {
        • state ⇐ state
        • buffer ⇐ buffer
}

defn reclaim_Buffers_from_heap (inst) {
    pass
}

defn deracer_instantiate (reg, owner, name, template_data) {
    name_with_id ≡ gensymbol (“deracer”)
    inst ≡ Deracer_Instance_Data (“idle”, TwoMessages (ϕ, ϕ))
    inst.state ⇐ “idle”
    eh ≡ make_leaf (name ∷ name_with_id, owner ∷ owner, instance_data ∷ inst, handler ∷ deracer_handler)
    return eh
}

defn send_first_then_second (eh, inst) {
    forward (eh, “1”, inst.buffer.first)
    forward (eh, “2”, inst.buffer.second)
    reclaim_Buffers_from_heap (inst)
}

