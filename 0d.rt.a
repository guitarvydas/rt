defvar counter ⇐ 0

defvar digits ⇐ [
    “₀”, “₁”, “₂”, “₃”, “₄”, “₅”,
    “₆”, “₇”, “₈”, “₉”,
    “₁₀”, “₁₁”, “₁₂”, “₁₃”, “₁₄”,
    “₁₅”, “₁₆”, “₁₇”, “₁₈”, “₁₉”,
    “₂₀”, “₂₁”, “₂₂”, “₂₃”, “₂₄”,
    “₂₅”, “₂₆”, “₂₇”, “₂₈”, “₂₉”
]

defn gensymbol (s) {
    global counter
    name_with_id ≡ strcons (s, subscripted_digit (counter))
    counter ⇐ counter + 1
    return name_with_id
}

defn subscripted_digit (n) {
  global digits
  if (n >=  0 and n <=  29) {
    return digits [n]
  } else {
    return strcons (“₊”, n)
  }
}

defobj Datum () {
      • data ⇐ ϕ
      • clone ⇐ ϕ
      • reclaim ⇐ ϕ
      • srepr ⇐ ϕ
      • kind ⇐ ϕ
      • raw ⇐ ϕ
}

defn new_datum_string (s) {
    d ≡ fresh (Datum)
    d.data ⇐ s
    d.clone ⇐ λ: clone_datum_string (d)
    d.reclaim ⇐ λ: reclaim_datum_string (d)    
    d.srepr ⇐ λ: srepr_datum_string (d)
    d.raw ⇐ λ: raw_datum_string (d)    
    d.kind ⇐ λ: “string”
    return d
}

defn clone_datum_string (d) {
  d ≡ new_datum_string (d.data)
  return d
}

defn reclaim_datum_string (src) {
  pass
}

defn srepr_datum_string (d) {
  return d.data
}

defn raw_datum_string (d) {
  return bytearray (d.data,“UTF_8”)
}

defn new_datum_bang () {
    p ≡ Datum ()
    p.data ⇐ ⊤
    p.clone ⇐ λ: clone_datum_bang (p)
    p.reclaim ⇐ λ: reclaim_datum_bang (p)
    p.srepr ⇐ λ: srepr_datum_bang ()
    p.raw ⇐ λ: raw_datum_bang ()    
    p.kind ⇐ λ: “bang”
    return p
}

defn clone_datum_bang (d) {
    return new_datum_bang ()
}

defn reclaim_datum_bang (d) {
    pass
}

defn srepr_datum_bang () {
    return “!”
}

defn raw_datum_bang () {
    return []
}

defn new_datum_tick () {
    p ≡ new_datum_bang ()
    p.kind ⇐ λ: “tick”
    p.clone ⇐ λ: new_datum_tick ()
    p.srepr ⇐ λ: srepr_datum_tick ()
    p.raw ⇐ λ: raw_datum_tick ()
    return p
}

defn srepr_datum_tick () {
    return “.”
}

defn raw_datum_tick () {
    return []
}

defn new_datum_bytes (b) {
    p ≡ Datum ()
    p.data ⇐ b
    p.clone ⇐ clone_datum_bytes
    p.reclaim ⇐ λ: reclaim_datum_bytes (p)
    p.srepr ⇐ λ: srepr_datum_bytes (b)
    p.raw ⇐ λ: raw_datum_bytes (b)
    p.kind ⇐ λ: “bytes”
    return p
}

defn clone_datum_bytes (src) {
    p ≡ Datum ()
    p ≡ src
    p.data ⇐ src.clone ()
    return p
}

defn reclaim_datum_bytes (src) {
    pass
}

defn srepr_datum_bytes (d) {
    return d.data.decode (“UTF_8”)
}
defn raw_datum_bytes (d) {
    return d.data
}

defn new_datum_handle (h) {
    return new_datum_int (h)
}

defn new_datum_int (i) {
    p ≡ Datum ()
    p.data ⇐ i
    p.clone ⇐ λ: clone_int (i)
    p.reclaim ⇐ λ: reclaim_int (i)
    p.srepr ⇐ λ: srepr_datum_int (i)
    p.raw ⇐ λ: raw_datum_int (i)
    p.kind ⇐ λ: “int”
    return p
}

defn clone_int (i) {
    p ≡ new_datum_int (i)
    return p
}

defn reclaim_int (src) {
    pass
}

defn srepr_datum_int (i) {
  return str (i)
}

defn raw_datum_int (i) {
    return i
}

⌈ Message passed to a leaf component.⌉
⌈⌉
⌈ `port` refers to the name of the incoming or outgoing port of this component.⌉
⌈ `datum` is the data attached to this message.⌉
defobj Message (port, datum) {
        • port ⇐ port
        • datum ⇐ datum
}

defn clone_port (s) {
    return clone_string (s)
}

⌈ Utility for making a `Message`. Used to safely “seed“ messages⌉
⌈ entering the very top of a network.⌉
defn make_message (port, datum) {
    p ≡ clone_string (port)
    m ≡ Message (p, datum.clone ())
    return m
}

⌈ Clones a message. Primarily used internally for “fanning out“ a message to multiple destinations.⌉
defn message_clone (message) {
    m ≡ Message (clone_port (message.port), message.datum.clone ())
    return m
}

⌈ Frees a message.⌉
defn destroy_message (msg) {
    ⌈ during debug, dont destroy any message, since we want to trace messages, thus, we need to persist ancestor messages⌉
    pass
}

defn destroy_datum (msg) {
    pass
}

defn destroy_port (msg) {
    pass
}

⌈⌉
defn format_message (m) {
    if m = ϕ {
        return “ϕ” }
    else {
        return strcons (“⟪”,
	         strcons (m.port,
		   strcons (“⦂”,
		     strcons (m.datum.srepr (), “⟫”))))
    }
}

⌈ dynamic routing descriptors⌉

defconst drInject ≡ “inject”
defconst drSend ≡ “send”
defconst drInOut ≡ “inout”
defconst drForward ≡ “forward”
defconst drDown ≡ “down”
defconst drUp ≡ “up”
defconst drAcross ≡ “across”
defconst drThrough ≡ “through”

⌈ See “class_free programming“ starting at 45:01 of https://www.youtube.com/watch?v=XFTOG895C7c⌉


defn make_Routing_Descriptor (action, component, port, message) {
    return {
        “action”: action,
        “component”: component,
        “port”: port,
        “message”: message
        }
}

⌈⌉
defn make_Send_Descriptor (component, port, message, cause_port, cause_message) {
    rdesc ≡ make_Routing_Descriptor (drSend, component, port, message)
    return {
        “action”: drSend,
        “component”: rdesc@component,
        “port”: rdesc@port,
        “message”: rdesc@message,
        “cause_port”: cause_port,
        “cause_message”: cause_message,
        “fmt”: fmt_send
        }
}

defn log_send (sender, sender_port, msg, cause_msg) {
    send_desc ≡ make_Send_Descriptor (sender, sender_port, msg, cause_msg.port, cause_msg)
    append_routing_descriptor (sender.owner, send_desc)
}

defn log_send_string (sender, sender_port, msg, cause_msg) {
    send_desc ≡ make_Send_Descriptor (sender, sender_port, msg, cause_msg.port, cause_msg)
    append_routing_descriptor (sender.owner, send_desc)
}

defn fmt_send (desc, indent) {
    return “”
    ⌈return f'\n{indent}⋯ {desc@component.name}.“{desc@cause_port}“ ∴ {desc@component.name}.“{desc@port}“ {format_message (desc@message)}'⌉
}

defn fmt_send_string (desc, indent) {
    return fmt_send (desc, indent)
}

⌈⌉
defn make_Forward_Descriptor (component, port, message, cause_port, cause_message) {
    rdesc ≡ make_Routing_Descriptor (drSend, component, port, message)
    fmt_forward ≡ λ (desc) : “”
    return {
        “action”: drForward,
        “component”: rdesc@component,
        “port”: rdesc@port,
        “message”: rdesc@message,
        “cause_port”: cause_port,
        “cause_message”: cause_message,
        “fmt”: fmt_forward
        }
}

defn log_forward (sender, sender_port, msg, cause_msg) {
    pass ⌈ when needed, it is too frequent to bother logging⌉
}

defn fmt_forward (desc) {
    print (strcons (“*** Error fmt_forward ”, desc))
    quit ()
}

⌈⌉
defn make_Inject_Descriptor (receiver, port, message) {
    rdesc ≡ make_Routing_Descriptor (drInject,  receiver,  port,  message)
    return {
        “action”: drInject,
        “component”: rdesc@component,
        “port”: rdesc@port,
        “message”: rdesc@message,
        “fmt” : fmt_inject
        }
}

defn log_inject (receiver, port, msg) {
    inject_desc ≡ make_Inject_Descriptor (receiver, port, msg)
    append_routing_descriptor (receiver, inject_desc)
}

defn fmt_inject (desc, indent) {
    ⌈return f'\n{indent}⟹  {desc@component.name}.“{desc@port}“ {format_message (desc@message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“⟹  ”,
	         strcons (desc@component.name,
		   strcons (“.”,
		     strcons (desc@port,
		       strcons (“ ”, format_message (desc@message))))))))
}

⌈⌉
defn make_Down_Descriptor (container, source_port, source_message, target, target_port, target_message) {
    return {
        “action”: drDown,
        “container”: container,
        “source_port”: source_port,
        “source_message”: source_message,
        “target”: target,
        “target_port”: target_port,
        “target_message”: target_message,
        “fmt” : fmt_down
        }
}

defn log_down (container, source_port, source_message, target, target_port, target_message) {
    rdesc ≡ make_Down_Descriptor (container, source_port, source_message, target, target_port, target_message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_down (desc, indent) {
    ⌈return f'\n{indent}↓ {desc@container.name}.“{desc@source_port}“ ➔ {desc@target.name}.“{desc@target_port}“ {format_message (desc@target_message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“ ↓ ”,
	         strcons (desc@container.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@target.name,
			   strcons (“.”,
			     strcons (desc@target_port,
			       strcons (“ ”, format_message (desc@target_message))))))))))))
}

⌈⌉
defn make_Up_Descriptor (source, source_port, source_message, container, container_port, container_message) {
    return {
        “action”: drUp,
        “source”: source,
        “source_port”: source_port,
        “source_message”: source_message,
        “container”: container,
        “container_port”: container_port,
        “container_message”: container_message,
        “fmt” : fmt_up
        }
}

defn log_up (source, source_port, source_message, container, target_port, target_message) {
    rdesc ≡ make_Up_Descriptor (source, source_port, source_message, container, target_port, target_message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_up (desc, indent) {
    ⌈return f'\n{indent}↑ {desc@source.name}.“{desc@source_port}“ ➔ {desc@container.name}.“{desc@container_port}“ {format_message (desc@container_message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“↑ ”,
	         strcons (desc@source.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@container.name,
			   strcons (“.”,
			     strcons (desc@container_port,
			       strcons (“ ”, format_message (desc@container_message))))))))))))
}

defn make_Across_Descriptor (container, source, source_port, source_message, target, target_port, target_message) {
    return {
        “action”: drAcross,
        “container”: container,
        “source”: source,
        “source_port”: source_port,
        “source_message”: source_message,
        “target”: target,
        “target_port”: target_port,
        “target_message”: target_message,
        “fmt” : fmt_across
        }
}

defn log_across (container, source, source_port, source_message, target, target_port, target_message) {
    rdesc ≡ make_Across_Descriptor (container, source, source_port, source_message, target, target_port, target_message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_across (desc, indent) {
    ⌈return f'\n{indent}→ {desc@source.name}.“{desc@source_port}“ ➔ {desc@target.name}.“{desc@target_port}“  {format_message (desc@target_message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“→ ”,
	         strcons (desc@source.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@target.name,
			   strcons (“.”,
			     strcons (desc@target_port,
			       strcons (“  ”, format_message (desc@target_message))))))))))))
}

⌈⌉
defn make_Through_Descriptor (container, source_port, source_message, target_port, message) {
    return {
        “action”: drThrough,
        “container”: container,
        “source_port”: source_port,
        “source_message”: source_message,
        “target_port”: target_port,
        “message”: message,
        “fmt” : fmt_through
        }
}

defn log_through (container, source_port, source_message, target_port, message) {
    rdesc ≡ make_Through_Descriptor (container, source_port, source_message, target_port, message)
    append_routing_descriptor (container, rdesc)
}

defn fmt_through (desc, indent) {
    ⌈return f'\n{indent}⇶ {desc @container.name}.“{desc@source_port}“ ➔ {desc@container.name}.“{desc@target_port}“ {format_message (desc@message)}'⌉
    return strcons (“\n”,
             strcons (indent,
	       strcons (“⇶ ”,
	         strcons (desc@container.name,
		   strcons (“.”,
		     strcons (desc@source_port,
		       strcons (“ ➔ ”,
		         strcons (desc@container.name,
			   strcons (“.”,
			     strcons (desc@target_port,
			       strcons (“ ”, format_message (desc@message))))))))))))
}

⌈⌉
defn make_InOut_Descriptor (container, component, in_message, out_port, out_message) {
    return {
        “action”: drInOut,
        “container”: container,
        “component”: component,
        “in_message”: in_message,
        “out_message”: out_message,
        “fmt” : fmt_inout
        }
}

defn log_inout (container, component, in_message) {
    if component.outq.empty () {
        log_inout_no_output (container, component, in_message) }
    else {
        log_inout_recursively (container, component, in_message, list (component.outq.queue)) }
}

defn log_inout_no_output (container, component, in_message) {
    rdesc ≡ make_InOut_Descriptor (container, component, in_message, ϕ, ϕ)
    append_routing_descriptor (container, rdesc)
}

defn log_inout_single (container, component, in_message, out_message) {
    rdesc ≡ make_InOut_Descriptor (container,  component, in_message, ϕ, out_message)
    append_routing_descriptor (container, rdesc)
}

defn log_inout_recursively (container, component, in_message, out_messages) {
    if [] = out_messages {
        pass }
    else {
        m ≡ car (out_messages)
        rest ≡ cdr (out_messages)
        log_inout_single (container, component, in_message, m)
        log_inout_recursively (container, component, in_message, rest) }
}

defn fmt_inout (desc, indent) {
    outm ≡ desc@out_message
    if ϕ = outm {
        return strcons (“\n”, strcons (indent, “  ⊥”))
    } else {
        return strcons (“\n”, 
                 strcons (indent,
		   strcons (“  ∴ ”,
		     strcons (desc@component.name,
		       strcons (“ ”, format_message (outm))))))
    }
}

defn log_tick (container, component, in_message) {
    pass
}

⌈⌉
defn routing_trace_all (container) {
    indent ≡ “”
    lis ≡ list (container.routings.queue)
    return recursive_routing_trace (container, lis, indent)
}

defn recursive_routing_trace (container, lis, indent) {
    if [] = lis {
        return “”}
    else {
        desc ≡ first (lis)
        formatted ≡ desc@fmt (desc, indent)
        return formatted + recursive_routing_trace (container, rest (lis), indent + “  ”)}
}

defconst enumDown ≡ 0
defconst enumAcross ≡ 1
defconst enumUp ≡ 2
defconst enumThrough ≡ 3

defn container_instantiator (reg, owner, container_name, desc) {
    global enumDown, enumUp, enumAcross, enumThrough
    container ≡ make_container (container_name, owner)
    children ≡ []
    children_by_id ≡ {} ⌈ not strictly necessary, but, we can remove 1 runtime lookup by “compiling it out“ here⌉
    ⌈ collect children⌉
    for child_desc in desc@children {
        child_instance ≡ get_component_instance (reg, child_desc@name, container)
        children.append (child_instance)
        children_by_id [child_desc@id] ⇐ child_instance }
    container.children ⇐ children
    me ≡ container
    
    connectors ≡ []
    for proto_conn in desc@connections {
        source_component ≡ ϕ
        target_component ≡ ϕ
        connector ≡ Connector ()
        if proto_conn@dir = enumDown {
            ⌈ JSON: {'dir': 0, 'source': {'name': '', 'id': 0}, 'source_port': '', 'target': {'name': 'Echo', 'id': 12}, 'target_port': ''},⌉
            connector.direction ⇐ “down”
            connector.sender ⇐ Sender (me.name, me, proto_conn@source_port)
            target_component ≡ children_by_id [proto_conn@target@id]
            if (target_component = ϕ) {
                load_error (strcons (“internal error: .Down connection target internal error ”, proto_conn@target))}
            else{
                connector.receiver ⇐ Receiver (target_component.name, target_component.inq, proto_conn@target_port, target_component)
                connectors.append (connector) }}
        elif proto_conn@dir = enumAcross {
            connector.direction ⇐ “across”
            source_component ≡ children_by_id [proto_conn@source@id]
            target_component ≡ children_by_id [proto_conn@target@id]
            if source_component = ϕ {
                load_error (strcons (“internal error: .Across connection source not ok ”, proto_conn@source)) }
            else {
                connector.sender ⇐ Sender (source_component.name, source_component, proto_conn@source_port)
                if target_component = ϕ {
                    load_error (strcons (“internal error: .Across connection target not ok ”, proto_conn.target)) }
                else {
                    connector.receiver ⇐ Receiver (target_component.name, target_component.inq, proto_conn@target_port, target_component)
                    connectors.append (connector)}}}
        elif proto_conn@dir = enumUp {
            connector.direction ⇐ “up”
            source_component ≡ children_by_id [proto_conn@source@id]
            if source_component = ϕ {
                print (strcons (“internal error: .Up connection source not ok ”, proto_conn@source)) }
            else {
                connector.sender ⇐ Sender (source_component.name, source_component, proto_conn@source_port)
                connector.receiver ⇐ Receiver (me.name, container.outq, proto_conn@target_port, me)
                connectors.append (connector) }}
        elif proto_conn@dir = enumThrough {
            connector.direction ⇐ “through”
            connector.sender ⇐ Sender (me.name, me, proto_conn@source_port)
            connector.receiver ⇐ Receiver (me.name, container.outq, proto_conn@target_port, me)
            connectors.append (connector) }}
            
    container.connections ⇐ connectors
    return container
}

⌈ The default handler for container components.⌉
defn container_handler (container, message) {
    route (container, ⌈ from= ⌉container, message) ⌈ references to 'self' are replaced by the container during instantiation⌉
    while any_child_ready (container) {
        step_children (container, message)}
}

⌈ Frees the given container and associated data.⌉
defn destroy_container (eh) {
    pass
}

defn fifo_is_empty (fifo) {
    return fifo.empty ()
}

⌈ Routing connection for a container component. The `direction` field has⌉
⌈ no affect on the default message routing system _ it is there for debugging⌉
⌈ purposes, or for reading by other tools.⌉

defobj Connector () {
        • direction ⇐ ϕ ⌈ down, across, up, through⌉
        • sender ⇐ ϕ
        • receiver ⇐ ϕ
}

⌈ `Sender` is used to “pattern match“ which `Receiver` a message should go to,⌉
⌈ based on component ID (pointer) and port name.⌉

defobj Sender (name, component, port) {
        • name ⇐ name
        • component ⇐ component ⌈ from⌉
        • port ⇐ port ⌈ from's port⌉
}

⌈ `Receiver` is a handle to a destination queue, and a `port` name to assign⌉
⌈ to incoming messages to this queue.⌉

defobj Receiver (name, queue, port, component) {
        • name ⇐ name
        • queue ⇐ queue ⌈ queue (input | output) of receiver⌉
        • port ⇐ port ⌈ destination port⌉
        • component ⇐ component ⌈ to (for bootstrap debug)⌉
}

⌈ Checks if two senders match, by pointer equality and port name matching.⌉
defn sender_eq (s1, s2) {
    same_components ≡ (s1.component = s2.component)
    same_ports ≡ (s1.port = s2.port)
    return same_components and same_ports
}

⌈ Delivers the given message to the receiver of this connector.⌉

defn deposit (parent, conn, message) {
    new_message ≡ make_message (conn.receiver.port, message.datum)
    log_connection (parent, conn, new_message)
    push_message (parent, conn.receiver.component, conn.receiver.queue, new_message)
}

defn force_tick (parent, eh) {
    tick_msg ≡ make_message (“.”, new_datum_tick ())
    push_message (parent, eh, eh.inq, tick_msg)
    return tick_msg
}

defn push_message (parent, receiver, inq, m) {
    inq.put (m)
    parent.visit_ordering.put (receiver)
}

defn is_self (child, container) {
    ⌈ in an earlier version “self“ was denoted as ϕ⌉
    return child = container
}

defn step_child (child, msg) {
    before_state ≡ child.state
    child.handler(child, msg)
    after_state ≡ child.state
    return [before_state = “idle” and after_state != “idle”, 
            before_state != “idle” and after_state != “idle”,
            before_state != “idle” and after_state = “idle”]
}

defn save_message (eh, msg) {
    eh.saved_messages.put (msg)
}

defn fetch_saved_message_and_clear (eh) {
    return eh.saved_messages.get ()
}

defn step_children (container, causingMessage) {
    container.state ⇐ “idle”
    for child in list (container.visit_ordering.queue) {
        ⌈ child = container represents self, skip it⌉
        if (not (is_self (child, container))){
            if (not (child.inq.empty ())){
                msg ≡ child.inq.get ()
                [began_long_run, continued_long_run, ended_long_run] ⇐ step_child (child, msg)
                if began_long_run {
                    save_message (child, msg)}
                elif continued_long_run {
                    pass }
                elif ended_long_run {
                    log_inout (container, child, fetch_saved_message_and_clear (child))}
                else {
                    log_inout (container, child, msg)}
                destroy_message(msg)}
            else {
                if child.state !=  “idle” {
                    msg ≡ force_tick (container, child)
                    child.handler(child, msg)
                    log_tick (container, child, msg)
                    destroy_message(msg)}}
            
            if child.state = “active” {
                ⌈ if child remains active, then the container must remain active and must propagate “ticks“ to child⌉
                container.state ⇐ “active”}
            
            while (not (child.outq.empty ())) {
                msg ≡ child.outq.get ()
                route(container, child, msg)
                destroy_message(msg)}}}


}

defn attempt_tick (parent, eh) {
    if eh.state != “idle” {
        force_tick (parent, eh)}
}

defn is_tick (msg) {
    return “tick” = msg.datum.kind ()
}

⌈ Routes a single message to all matching destinations, according to⌉
⌈ the container's connection network.⌉

defn route (container, from_component, message) {
    deftemp was_sent ⇐ ⊥ ⌈ for checking that output went somewhere (at least during bootstrap)⌉
    deftemp fromname ⇐ “”
    if is_tick (message){
        for child in container.children {
            attempt_tick (container, child, message) }
        was_sent ⇐ ⊤ }
    else {
        if (not (is_self (from_component, container))) {
            fromname ⇐ from_component.name }
        from_sender ≡ Sender (fromname, from_component, message.port)
        
        for connector in container.connections {
            if sender_eq (from_sender, connector.sender) {
                deposit (container, connector, message)
                was_sent ⇐ ⊤}}}
    if not (was_sent) {
        print (“\n\n*** Error: ***”)
        dump_possible_connections (container)
        print_routing_trace (container)
        print (“***”)
        print (strcons (container.name, strcons (“: message '”, strcons (message.port, strcons (“' from ”, strcons (fromname, “ dropped on floor...”))))))
        print (“***”)
        exit () }
}

defn dump_possible_connections (container) {
    print (strcons (“*** possible connections for ”, strcons (container.name, “:”)))
    for connector in container.connections {
        print (strcons (connector.direction, strcons (“ ”, strcons (connector.sender.name, strcons (“.”, strcons (connector.sender.port, strcons (“ -> ”, strcons (connector.receiver.name, strcons (“.”, connector.receiver.port))))))))) }
}

defn any_child_ready (container) {
    for child in container.children {
        if child_is_ready(child) {
            return ⊤}}
    return ⊥
}

defn child_is_ready (eh) {
    return (not (eh.outq.empty ())) or (not (eh.inq.empty ())) or ( eh.state != “idle”) or (any_child_ready (eh))
}

defn print_routing_trace (eh) {
    print (routing_trace_all (eh))
}

defn append_routing_descriptor (container, desc) {
    container.routings.put (desc)
}

defn log_connection (container, connector, message) {
    if “down” = connector.direction{
        log_down (container,
	          ⌈ source port = ⌉connector.sender.port,
		  ⌈ source message = ⌉ϕ,
		  ⌈ target = ⌉connector.receiver.component,
		  ⌈ target port = ⌉connector.receiver.port,
                  ⌈ target message = ⌉message) }
    elif “up” = connector.direction {
        log_up (connector.sender.component, connector.sender.port, ϕ, container, connector.receiver.port, message) }
    elif “across” = connector.direction {
        log_across (container,
                    connector.sender.component, connector.sender.port, ϕ,
                    connector.receiver.component, connector.receiver.port, message) }
    elif “through” = connector.direction {
        log_through (container, connector.sender.port, ϕ,
                     connector.receiver.port, message) }
    else {
        print (strcons (“*** FATAL error: in log_connection /”, strcons (connector.direction, strcons (“/ /”, strcons (message.port, strcons (“/ /”, strcons (message.datum.srepr (), “/”)))))))
        exit () }
}

defn container_injector (container, message) {
    log_inject (container, message.port, message)
    container_handler (container, message)
}

